# 1.0.0

---

### Version Updates

- [Revision 1.0.3](https://github.com/sinclairzx81/typebox/pull/1321)
  - Add Variadic Signature Inference
- [Revision 1.0.2](https://github.com/sinclairzx81/typebox/pull/1320)
  - Remove Unreachable Assertion on Decode
- [Revision 1.0.1](https://github.com/sinclairzx81/typebox/pull/1315)
  - Ensure Infer Type is Cached on TUnsafe


---

A Runtime Type System for JavaScript

# Contents

- [Install](#Install)
- [Legacy](#Legacy)
- [Features](#Features)
  - [TypeScript](#TypeScript)
  - [Compiler](#Compiler)
  - [Remote](#Remote)
  - [Formats](#Formats)
  - [Locales](#Locales)
- [Types](#Types)
  - [Enum](#Enum)
  - [Module](#Module)
  - [Interface](#Interface)
  - [Evaluate](#Evaluate)
  - [Refine](#Refine)
- [Migration](#Migration)


<a name="Install"></a>

# Install

TypeBox 1.0 will be published under the `typebox` NPM package name.

```bash
$ npm install typebox --save                         # TypeBox 1.0.0

$ npm install @sinclair/typebox --save               # TypeBox 0.34.x
```

<a name="Legacy"></a>

# Legacy

TypeBox will provide a legacy support for users on pre-1.0 versions. The @sinclair/typebox package will continue receive updates into 2026 under the `0.34.x` version but will be limited to bug fixes only. The @sinclair/typebox package will eventually be synchronized with the 1.0 package where-in both will adopt post-1.0 semantic versioning. 

> The support window for `0.34.x` is yet to be determined but will be reviewed early-mid 2026. The decision to sync packages will be based on general 1.0 adoption observed at the time. Syncing packages is not anticipated until mid-2026 at the earliest.

# Features

The following features are supported in TypeBox 1.0.

<a name="TypeScript"></a>

## TypeScript

Version 1.0 adds a new Script function that offers runtime TypeScript emulation. This feature was developed in preparation of TypeScript 7 native which offers accelerated language service performance. 

### Example

The following shows Script usage.

```typescript
// Script

const T = Type.Script(`{ 
  x: number, 
  y: number, 
  z: number 
}`)

// Transform

const S = Type.Script({ T }, `{ 
  [K in keyof T as Uppercase<K>]: T[K] | null 
}`)

// Introspect

S.properties.X.anyOf[0]                             // { type: 'number' }
S.properties.X.anyOf[1]                             // { type: 'null' }
```

<a name="Compiler"></a>

## Compiler

Version 1.0 adds a new compiler for Json Schema and Standard Schema. The 1.0 compiler has been redesigned from the ground up to support direct compilation of Json Schema. Standard Schema is supported via keyword extension where `~standard` is used as non-standard Json Schema vocabulary. The 1.0 compiler also supports inference of Json Schema and Standard Schema.

### Example

The 1.0 compiler supports all of the following.

```typescript
import { Compile } from 'typebox/compile'

// Unified Compile: TypeBox | Json Schema | Standard Schema 

const X = Compile(Type.Script(`1 | 2 | 3`))

const Y = Compile({ anyOf: [{ const: 1 }, { const: 2 }, { const: 3 }] })

const Z = Compile(z.union([z.literal(1), z.literal(2), z.literal(3)])) // Zod

// Unified Parse and Inference

const A = X.Parse(1)                                // const A: 1 | 2 | 3

const B = Y.Parse(2)                                // const B: 1 | 2 | 3

const C = Z.Parse(3)                                // const C: 1 | 2 | 3
```

<a name="Remote"></a>

## Remote Types

Version 1.0 adds support for remote type embedding via Standard Schema. TypeBox will interpret the Standard Schema `~standard` property as extended Json Schema vocabulary. This approach enables remote types to be naturally embedded in schematics as well as checked by validators that support custom keyword configuration.

Remote types are supported across Type, Value and Compile submodules. Remote type inference using Static is also supported.

### Example

The following embeds Valibot and Zod in TypeBox types.

```typescript
import * as v from 'npm:valibot'
import * as z from 'npm:zod'

const A = z.literal('zod')
const B = v.literal('valibot')

const T = Type.Object({                             // const T: TObject<{
  lib: Type.Union([A, B])                           //   lib: TUnion<[
})                                                  //     z.ZodLiteral<'zod'>,                         
                                                    //     v.LiteralSchema<'valibot'>
                                                    //   ]>
                                                    // }>

// Inferred Remote Types

type T = Static<typeof T>                           // type T = {
                                                    //   lib: 'zod' | 'valibot'
                                                    // }
```

<a name="Formats"></a>

## Formats

TypeBox 1.0 adds a full suite of RFC-compliant string format checkers. The initial formats provided correspond to those referenced in the Json Schema specification. The formats are automatically configured for schema validation but can be called directly via submodule import.

### Example

The following validates an Email.

```typescript
const T = Type.String({ format: 'email' })

const R = Value.Check(T, 'user@domain.com')         // true
```

The following validates an Email via submodule import.

```typescript

import Format from 'typebox/format'

const R = Format.IsEmail('user@domain.com')         // true
```

<a name="Locales"></a>

## Locales

Versions 1.0 adds error message translations for 40+ languages. 

### Example

Locales can be configured via the System submodule.

```typescript
import { Locale } from 'typebox/system'

const T = Type.Number()

// ----------

Locale.Set(Locale.en_US)                            // English - United States

Value.Errors(T, 'not a number')                     // [{ ...message: 'must be number' }]

// ----------

Locale.Set(Locale.ko_KR)                            // Korean - South Korea

Value.Errors(T, 'not a number')                     // [{ ...message: 'number 이어야 합니다' }]

// ----------

Locale.Set(Locale.zh_Hans)                          // Chinese - Simplified

Value.Errors(T, 'not a number')                     // [{ ...message: '必须是 number' }]
```

# Types

The following types are available in TypeBox 1.0

<a name="Enum"></a>

## Enum

Version 1.0 adds compositor support for `enum` schema representations. 

```typescript
const A = Type.Enum(['A', 'B', 'C'])                // const A = {
                                                    //   enum: ['A', 'B', 'C']
                                                    // }

type A = Static<typeof A>                           // type A = 'A' | 'B' | 'C'
```

<a name="Module"></a>

## Module

Version 1.0 adds several new features to Module including immediate type return, automatic reference inlining and cyclic type detection.

### Example

The following shows immediate type return and reference inlining.

```typescript
const { A, B, C } = Type.Module({
  A: Type.Number(),                                 // const A: TNumber

  B: Type.String(),                                 // const B: TString

  C: Type.Object({                                  // const C: TObject<{
    a: Type.Ref('A'),                               //   TNumber, // <--- inline
    b: Type.Ref('B'),                               //   TString  // <--- inline
  })                                                // }>
})

```

<a name="Interface"></a>

## Interface

Version 1.0 adds a Interface type.

### Example

The following creates three interfaces where `C` extends `A` and `B`.

```typescript
const A = Type.Interface([], {                      // const A: TObject<{
  a: Type.Number()                                  //   a: TNumber
})                                                  // }>

const B = Type.Interface([], {                      // const B: TObject<{
  b: Type.Number()                                  //   b: TNumber
 })                                                 // }>

const C = Type.Interface([A, B], {                  // const C: TObject<{
  c: Type.Number()                                  //   a: TNumber,
})                                                  //   b: TNumber,
                                                    //   c: TNumber
                                                    // }
```

<a name="Evaluate"></a>

## Evaluate

Version 1.0 adds a new Evaluate type. This type can be used to evaluate logical Intersect and Union types into normalized forms. 

### Example

The following evaluates an intersection of Objects, returning a single Object.

```typescript
const T = Type.Intersect([                     // const T: TIntersect<[
  Type.Object({ x: Type.Number() }),           //   TObject<{ x: TNumber }>,
  Type.Object({ y: Type.Number() }),           //   TObject<{ y: TNumber }>,
  Type.Object({ z: Type.Number() })            //   TObject<{ z: TNumber }>,
])                                             // ]>


const S = Type.Evaluate(T)                     // const S: TObject<{
                                               //  x: TNumber,
                                               //  y: TNumber,
                                               //  z: TNumber
                                               // }>
```

<a name="Refine"></a>

## Refine

Version 1.0 adds a Refine function. 

### Example

The following uses Refine to test that properties `x` and `y` are equal with optional error message.

```typescript
const T = Type.Refine(Type.Object({
  x: Type.Number(),
  y: Type.Number()
}), value => value.x === value.y, 'x should equal w')


const R1 = Value.Check(T, { x: 1, y: 1 })           // true
const R2 = Value.Check(T, { x: 1, y: 2 })           // false
```

<a name="Migration"></a>

## Migration

Version 1.0 is a complete rebuild of TypeBox. While attempts have been made to retain the pre-1.0 API surface, there are several significant breaking changes that warrant a major revision tick. A migration guide has been prepared that documents upgrading from `0.34.x` to `1.0.0`. The guide can be found at the link below.

[TypeBox 1.0 Migration Guide](/changelog/1.0.0-migration.md)
