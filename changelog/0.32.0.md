## [0.32.0](https://www.npmjs.com/package/@sinclair/typebox/v/0.32.0)

## Overview

Revision 0.32.0 includes a full refactor of TypeBox's internals to modularize the type system as well as to enable ESM publishing. This revision includes many new additions, including three new types (Mapped, Const and Deref), two new Value functions (Clean and Default) as well as the ability to selectively import types. This revision carries out dozens of internal optimizations to type inference, as well as implementing a new inference strategy that seeks to unify static inference logic with runtime logic.

This update has some breaking changes and requires a minor revision.

## Contents

- [Modularization](#Modularization)
- [Selective Type Imports](#Modularization-Selective-Type-Imports)
- [Selective Value Function Import](#Modularization-Selective-Value-Function-Imports)
- [CommonJS and ESM](#Modularization-CommonJS-and-ESM)
- [New Types](#Types)
  - [Mapped Types](#Types-Mapped-Types)
  - [Const Types](#Types-Const-Types)
  - [Deref Types](#Types-Deref-Types)
- [New Value Functions](#Values)
  - [Clean Function](#Values-Clean-Function)
  - [Default Function](#Values-Default-Function)
- [Optimizations](#Optimizations)
  - [Bundle Size](#Optimizations-Bundle-Size)
- [Breaking](#Breaking)
  - [Value Submodule Imports](#Breaking-Value-Submodule-Imports)
  - [ErrorFunction](#Breaking-ErrorFunction)
  - [RegEx](#Breaking-RegEx)


<a name="Modularization"></a>

## Modularization

Revision 0.32.0 fully modularizes both the type system, as well as value and error submodules. The following sections outline the changes.

<a name="Modularization-Selective-Type-Imports"></a>

### Selective Type Imports

TypeBox now offers the ability to import types individually. Selective imports can significantly reduce bundle sizes. 

```typescript
import { Type, type Static } from '@sinclair/typebox'                   // classic - 36.5 kb

import { Object, String, Number, type Static } from '@sinclair/typebox' // selective - 6.5 kb
```

<a name="Modularization-Selective-Value-Function-Imports"></a>

### Selective Value Function Imports

Revision 0.32.0 adds the ability to selectively import value functions individually. Selectively importing functions can significantly reduce bundle sizes. 

```typescript
import { Value } from '@sinclair/typebox/value'                         // classic - 61.5 kb

import { Check } from '@sinclair/typebox/value'                         // selective - 18.2 kb
```

### CommonJS and ESM

<a name="Modularization-CommonJS-and-ESM"></a>

TypeBox now publishes both CommonJS and ESM builds of TypeBox. Current CommonJS users should not be impacted by this change, however ESM users, particularily those building with bundlers can now benefit from deep tree shaking optimizations provided by most modern bundlers. 

To achieve dual CommonJS and ESM publishing, TypeBox employs a new build system designed specifically to target the [package-json-redirect](https://github.com/andrewbranch/example-subpath-exports-ts-compat/tree/main/examples/node_modules/package-json-redirects) mechanism. This mechanism supports both type and module resolution (pre and post node16), while also supporting submodule redirection for types when using TypeScript without configuration. TypeBox also adopts the excellent [arethetypeswrong](https://github.com/arethetypeswrong/arethetypeswrong.github.io) CLI tooling to help verify the correctness of output builds.

```
┌───────────────────┬─────────────────────┬──────────────────────────────┬────────────────────────────┬────────────────────────────┬──────────────────────────┬───────────────────────────┐
│                   │ "@sinclair/typebox" │ "@sinclair/typebox/compiler" │ "@sinclair/typebox/errors" │ "@sinclair/typebox/system" │ "@sinclair/typebox/type" │ "@sinclair/typebox/value" │
├───────────────────┼─────────────────────┼──────────────────────────────┼────────────────────────────┼────────────────────────────┼──────────────────────────┼───────────────────────────┤
│ node10            │ 🟢                  │ 🟢                          │ 🟢                        │ 🟢                         │ 🟢                      │ 🟢                        │
├───────────────────┼─────────────────────┼──────────────────────────────┼────────────────────────────┼────────────────────────────┼──────────────────────────┼───────────────────────────┤
│ node16 (from CJS) │ 🟢 (CJS)            │ 🟢 (CJS)                    │ 🟢 (CJS)                  │ 🟢 (CJS)                   │ 🟢 (CJS)                │ 🟢 (CJS)                  │
├───────────────────┼─────────────────────┼──────────────────────────────┼────────────────────────────┼────────────────────────────┼──────────────────────────┼───────────────────────────┤
│ node16 (from ESM) │ 🟢 (ESM)            │ 🟢 (ESM)                    │ 🟢 (ESM)                  │ 🟢 (ESM)                   │ 🟢 (ESM)                │ 🟢 (ESM)                  │
├───────────────────┼─────────────────────┼──────────────────────────────┼────────────────────────────┼────────────────────────────┼──────────────────────────┼───────────────────────────┤
│ bundler           │ 🟢                  │ 🟢                          │ 🟢                        │ 🟢                         │ 🟢                      │ 🟢                        │
└───────────────────┴─────────────────────┴──────────────────────────────┴────────────────────────────┴────────────────────────────┴──────────────────────────┴───────────────────────────┘
```

<a name="Types"></a>

## Types

Revision 0.32.0 adds three new types to the type system.

<a name="Types-Mapped-Types"></a>

### Mapped Types

Revision 0.32.0 adds a new Mapped type which emulates TypeScript [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html) at runtime, as well as statically emulating the feature in the TypeScript type system. The following shows both TypeScript and TypeBox versions of this feature.

#### TypeScript

```typescript
type T = {
  x: number,
  y: number,
  z: number
}

type M = { [K in keyof T]: T[K] } // a mapped type
```
#### TypeBox
```typescript
const T = Type.Object({
  x: Type.Number(),
  y: Type.Number(),
  z: Type.Number()
})

const M = Type.Mapped(Type.KeyOf(T), K => Type.Index(T, K)) // a mapped type
```
Mapped types are an advanced feature built to be a runtime target for TypeScript [AST Transformations](https://sinclairzx81.github.io/typebox-workbench/?share=dHlwZSBUID0gewogIHg6IG51bWJlciwKICB5OiBudW1iZXIsCiAgejogbnVtYmVyCn0KCnR5cGUgTSA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gfSAvLyBtYXBwZWQ%3D). Users interested in this feature can experiment and test via the [TypeBox Workbench](https://sinclairzx81.github.io/typebox-workbench/) which will generate the TypeBox mapped type derived from the TypeScript syntax. Note also that due to the complexity of this type, TypeBox currently only supports a upper limit of 32 mapped properties (as given by the `KeyOf`), additional optimizations will be investigated over the course of 0.32.0 to try and increase this figure.


<a name="Types-Const-Types"></a>

### Const Types

Revision 0.32.0 adds a new Const type that will generate `readonly` types from JavaScript literal values. This type mirrors TypeScript types appended with `as const`. The following shows general usage.

```typescript
const A = Type.Const(1 as const)                               // const A: TLiteral<1>

const B = Type.Const([1, 2, 3] as const)                       // const B: TReadonly<TTuple<[
                                                               //   TLiteral<1>,
                                                               //   TLiteral<2>,
                                                               //   TLiteral<3>
                                                               // ]>>

const B = Type.Const({                                         // const C: TObject<{
  x: 1,                                                        //  x: TReadonly<TLiteral<1>>,
  y: 2,                                                        //  y: TReadonly<TLiteral<2>>,
  z: 3                                                         //  z: TReadonly<TLiteral<3>>,
} as const)                                                    // }>                                            
```
As TypeBox continues to support TypeScript 4.0, the `as const` must be appended to each literal value passed to this type. When TypeBox drops support for 4.0, updates will be made to this this type to leverage [Const Type Parameters](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#const-type-parameters) which enables TypeScript to correctly infer the literal without `as const`.


<a name="Types-Deref-Types"></a>

### Deref Types

Revision 0.32.0 adds a new Type.Deref type which can be used to dereference types.

```typescript
const Vector = Type.Object({                                   // const Vector = {
  x: Type.Number(),                                            //   type: 'object',
  y: Type.Number(),                                            //   required: ['x', 'y', 'z'],
}, { $id: 'Vector' })                                          //   properties: {
                                                               //     x: { type: 'number' },
                                                               //     y: { type: 'number' }
                                                               //   },
                                                               //   $id: 'Vector'
                                                               // }

const VectorRef = Type.Ref(Vector)                             // const VectorRef = {
                                                               //   $ref: 'Vector'
                                                               // }
// ... Embedded Reference Type

const Vertex = Type.Object({                                   // const Vertex = {
  position: VectorRef,                                         //   type: 'object',
  texcoord: VectorRef,                                         //   required: ['position', 'texcoord'],
})                                                             //   properties: {
                                                               //     position: { $ref: 'Vector' },
                                                               //     texcoord: { $ref: 'Vector' }
                                                               //   }
                                                               // }

// ... Dereferenced Embedded Reference Type

const VertexDeref = Type.Deref(Vertex, [Vector])               // const VertexDeref = {
                                                               //   type: 'object',
                                                               //   required: ['position', 'texcoord'],
                                                               //   properties: {
                                                               //     position: {
                                                               //       type: 'object',
                                                               //       required: ['x', 'y', 'z'],
                                                               //       properties: {
                                                               //         x: { type: 'number' },
                                                               //         y: { type: 'number' }
                                                               //       }
                                                               //     },
                                                               //     texcoord: {
                                                               //       type: 'object',
                                                               //       required: ['x', 'y', 'z'],
                                                               //       properties: {
                                                               //         x: { type: 'number' },
                                                               //         y: { type: 'number' }
                                                               //       }
                                                               //     }
                                                               //   }
                                                               // }
```
This type was prompted by users attempting to compose Ref types with mapping types such as Partial, Required, Pick and Omit. Prior to Revision 0.32.0, the expectation was for users to maintain and dereference types prior to calling these mapping types. In 0.32.0, users will still need to maintain foreign references to referenced types, but Deref will be the recommended mechanism to normalize the type prior to composition.


<a name="Values"></a>

## Values

Revision 0.32.0 adds two new functions to the Value module.

<a name="Values-Clean-Function"></a>

### Clean Function

Revision 0.32.0 adds a new Clean function that can be used to omit any values unknown to the type. This function will work irrespective of if `additionalProperties` is specified on the type. The Clean function is intended to mirror the functionality of Ajv's `removeAdditional` configuration.

```typescript
const T = Type.Object({ 
  x: Type.Number(), 
  y: Type.Number() 
})

const X = Value.Clean(T, null)                                  // const 'X = null

const Y = Value.Clean(T, { x: 1 })                              // const 'Y = { x: 1 }

const Z = Value.Clean(T, { x: 1, y: 2, z: 3 })                  // const 'Z = { x: 1, y: 2 }
```

Note: the Clean function does not check the validity of the value being cleaned, and does not provide assurances that the result will be valid. Its return value is `unknown` and should be checked before use.

<a name="Values-Default-Function"></a>

### Default Function

Revision 0.32.0 adds a new Default function that can be used to add missing values if the type specifies a `default` annotation. This function is used to mirror Ajv's `useDefaults` functionality.

```typescript
const T = Type.Object({ 
  x: Type.Number({ default: 0 }), 
  y: Type.Number({ default: 0 })
})

const X = Value.Default(T, null)                               // const 'X = null - non-enumerable

const Y = Value.Default(T, { })                                // const 'Y = { x: 0, y: 0 }

const Z = Value.Default(T, { x: 1 })                           // const 'Z = { x: 1, y: 0 }
```

The Default function does not check the validity of the value being defaulted, and does not provide assurances that the result will be valid. Its return value is `unknown` and should be checked before use.

<a name="Optimizations"></a>

## Optimizations

Following the work to modularize TypeBox's type system, additional optimizations were carried out across each submodule to only import dependent type infrastructure. This has led to some fairly significant reductions in output sizes across each submodule. The main TypeBox import has increased however by 4kb in due in part to the new mapped types feature, however selective imports supported on this revision should offer options for users concerned about output bundle size.

The following shows the comparisons between 0.31.0 and 0.32.0.

<a name="Optimizations-Bundle-Size"></a>

```typescript
// Revision 0.31.0

┌──────────────────────┬────────────┬────────────┬─────────────┐
│       (index)        │  Compiled  │  Minified  │ Compression │
├──────────────────────┼────────────┼────────────┼─────────────┤
│ typebox/compiler     │ '163.6 kb' │ ' 71.6 kb' │  '2.28 x'   │
│ typebox/errors       │ '113.3 kb' │ ' 50.1 kb' │  '2.26 x'   │
│ typebox/system       │ ' 83.9 kb' │ ' 37.5 kb' │  '2.24 x'   │
│ typebox/value        │ '191.1 kb' │ ' 82.3 kb' │  '2.32 x'   │
│ typebox              │ ' 73.8 kb' │ ' 32.3 kb' │  '2.29 x'   │
└──────────────────────┴────────────┴────────────┴─────────────┘

//  Revision 0.32.0

┌──────────────────────┬────────────┬────────────┬─────────────┐
│       (index)        │  Compiled  │  Minified  │ Compression │
├──────────────────────┼────────────┼────────────┼─────────────┤
│ typebox/compiler     │ '118.3 kb' │ ' 52.4 kb' │  '2.26 x'   │
│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │
│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │
│ typebox/value        │ '144.0 kb' │ ' 61.5 kb' │  '2.34 x'   │
│ typebox              │ ' 87.0 kb' │ ' 36.5 kb' │  '2.39 x'   │
└──────────────────────┴────────────┴────────────┴─────────────┘
```

<a name="Breaking"></a>

## Breaking

The following list the breaking changes in Revision 0.32.0.

<a name="Breaking-Value-Submodule-Imports"></a>

### Value Submodule Imports

The value submodule function import paths are unfortunately no longer supported. Instead, these can be imported directly on the `/value` path. The need to break the submodule paths was mostly due to complexities configuring dual ESM and CommonJS publishing for the package, as well as retaining support for pre and post node16 module resolution (of which many complexities reside, both for Node as well as for TypeScript type module resolution)

```typescript
// Revision 0.31.0

import { Check } from '@sinclair/typebox/value/check'

// Revision 0.32.0

import { Check } from '@sinclair/typebox/value'
```

<a name="Breaking-ErrorFunction"></a>

### ErrorFunction

The TypeSystemErrorFunction has been removed, and replaced with SetErrorFunction which can be imported on the `/errors` submodule. This change is generally a tidy up, and to reserve the `/system` submodule specifically for type system policy configuration.

```typescript
// Revision 0.31.0

import { TypeSystemErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/system'

TypeSystemErrorFunction.Set((schema, errorType) => { // i18n override
  switch(errorType) {
    /* en-US */ case ValueErrorType.String: return 'Expected string'
    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  
    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      
    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          
  }
})

// Revision 0.32.0

import { SetErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/errors'

SetErrorFunction((schema, errorType) => { // i18n override
  switch(errorType) {
    /* en-US */ case ValueErrorType.String: return 'Expected string'
    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  
    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      
    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          
  }
})
```

<a name="Breaking-RegEx"></a>

### RegEx

This RegEx function was flagged for deprecation on 0.30.0. It has been removed on 0.32.0. Use the Type.RegExp type, or Type.String with a pattern.

```typescript
// Revision 0.31.0

const T = Type.RegEx(/abc/)                                    // deprecation warning

// Revision 0.32.0

const B = Type.RegExp(/abc/)                                   // Extended Type

const T = Type.String({ pattern: /abc/.source })               // Standard Type
```