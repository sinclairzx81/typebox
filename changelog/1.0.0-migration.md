# 1.0.0 Migration Guide

This document covers upgrading from TypeBox 0.34.x to  1.0. While most of the API surface remains intact for 1.0, there are several key breaking changes that will impact users who integrate deeply with TypeBox infrastructure. 

The sections below document these changes and detail strategies for upgrading.

# Changes

- [Kind, Hint, ReadonlyKind and OptionalKind](#Symbols)
- [Type.Date and Type.Uint8Array](#Globals)
- [Type.Recursive](#Recursive)
- [Type.RegExp](#RegExp)
- [Type.Composite](#Composite)
- [Type.Transform](#Transform)
- [Type.Const](#Const)
- [TypeCompiler](#TypeCompiler)
- [References](#References)
- [FormatRegistry](#FormatRegistry)
- [TypeRegistry](#TypeRegistry)
- [TypeGuard](#TypeGuard)
- [Value.Errors](#Errors)
- [Value.Cast](#Cast)


<a name="Symbols"></a>

# Kind, Hint, ReadonlyKind and OptionalKind

Version 1.0 removes the Kind, ReadonlyKind, OptionalKind symbols. These symbols were originally introduced to enable fast type differentiation, as well as to resolve integration issues with Ajv strict mode.

The use of symbols have proven difficult for users who install multiple versions of TypeBox side by side. This is most notable in frameworks that install one version of TypeBox and where users install another. The removal of symbols will enable multiple version of TypeBox to run side by side without requiring users to pin specific versions via package.json.

Version 1.0 replaces each symbol with non-enumerable `~kind`, `~readonly` and `~optional` properties. Applications that use symbols to reflect TypeBox types will need to update to read these properties instead. 

## Example

0.34.x

```typescript
import { Type, Kind } from '@sinclair/typebox'

const T = Type.String()

if(T[Kind] === 'String') { ... }
```

1.0.0

```typescript
import Type from 'typebox'

const T = Type.String()

if(T['~kind'] === 'String') { ... }

// Consider using guards instead of direct property access.

if(Type.IsString(T)) { ... }
```

<a name="Globals"></a>

# Type.Date and Type.Uint8Array

Version 1.0 removes the Date and Uint8Array types. These types can be created at an application level by extending Type.Base.

## Fallback 

[Uint8Array](/example/legacy/uint8array.ts) | [Date](/example/legacy/date.ts)

## Example

The following implements Uint8Array using Type.Base. 

```typescript
import Type from 'typebox'

// Definition
export class TUint8Array extends Type.Base<Uint8Array> {
  public override Check(value: unknown): value is Uint8Array {
    return value instanceof Uint8Array
  }
  public override Errors(value: unknown): object[] {
    return !this.Check(value) ? [{ message: 'Not a Uint8Array'}] : []
  }
}
// Factory
export function Uint8Array(): TUint8Array {
  return new TUint8Array()
}
```

<a name="Recursive"></a>

# Type.Recursive

Version 1.0 removes the Recursive type. This type has been replaced with a new Cyclic type that supports both singular and mutual recursive types.

## Fallback

[Recursive](/example/legacy/recursive.ts)

## Example

0.34.x

```typescript
const Node = Type.Recursive(This => Type.Object({
  id: Type.Number(),
  nodes: Type.Array(This)
}))
```

1.0.0

```typescript
const Node = Type.Cyclic({
  Node: Type.Object({
    id: Type.Number(),
    nodes: Type.Array(Type.Ref('Node'))
  })
}, 'Node')
```

<a name="RegExp"></a>

# Type.RegExp

Version 1.0 removes the RegExp type. TypeBox now allows regular expressions to be passed via `pattern` to String types.

## Fallback

[RegExp](/example/legacy/regexp.ts)

## Example

0.34.x

```typescript
const T = Type.RegExp(/abc/i)
```

1.0.0

```typescript
const T = Type.String({ pattern: /abc/i })
```

<a name="Composite"></a>

# Type.Composite

Version 1.0 removes the Composite type. This type have been replaced by the Interface and Evaluate types. 

## Fallback

[Composite](/example/legacy/composite.ts)

## Example

0.34.x

```typescript
const A = Type.Object({ a: Type.Number() })
const B = Type.Object({ b: Type.Number() })
const C = Type.Composite([A, B])
```

1.0.0

```typescript
// Composite using Interface and Heritage
const A = Type.Object({ a: Type.Number() })
const B = Type.Interface([A], { b: Type.Number() })

// Composite using Evaluate
const A = Type.Object({ a: Type.Number() })
const B = Type.Object({ b: Type.Number() })
const C = Type.Evaluate(Type.Intersect([A, B]))
```

<a name="Transform"></a>

# Type.Transform

The Transform type has been renamed to Codec. This name change better reflects bi-directional transformation vs uni-directional transformation. Uni-directional transformation is a feature of TypeBox 1.0.

## Fallback

[Transform](/example/legacy/transform.ts)

## Example

0.34.x

```typescript
const NumberToString = Type.Transform(Type.Number())
  .Decode(value => value.toString())
  .Encode(value => parseFloat(value))

```

1.0.0

```typescript
// Bi-Directional
const NumberToString = Type.Codec(Type.Number())
  .Decode(value => value.toString())
  .Encode(value => parseFloat(value))

// Uni-Directional
const NumberToStringDecode = Type.Decode(Type.Number(), value => value.toString())
const NumberToStringEncode = Type.Encode(Type.Number(), (value: number) => value.toString())
```

<a name="Const"></a>

# Type.Const

The Const type has been removed in 1.0. This type was originally used to create structural type representations from constant TypeScript values. 1.0 deprecates this functionality in favor of Script which can parse values into structural representations.

## Fallback

[Const](/example/legacy/const.ts)

## Example

0.34.x

```typescript
const T = Type.Const({ x: 1, y: 2, z: 3 } as const) // const T: TObject<{
                                                    //   TReadonly<TLiteral<1>>
                                                    //   TReadonly<TLiteral<2>>
                                                    //   TReadonly<TLiteral<3>>
                                                    // }>
```

1.0.0

```typescript
const T = Type.Script(`{ x: 1, y: 2, z: 3 }`)       // const T: TObject<{
                                                    //   x: TLiteral<1>;
                                                    //   y: TLiteral<2>;
                                                    //   z: TLiteral<3>;
                                                    // }>

// Optional: If readonly is required.

const S = Type.Script({ T }, `{
  readonly [K in keyof T]: T[K]  
}`)                                                 // const S: TObject<{
                                                    //   x: TReadonly<TLiteral<1>>;
                                                    //   y: TReadonly<TLiteral<2>>;
                                                    //   z: TReadonly<TLiteral<3>>;
                                                    // }>
```


<a name="TypeCompiler"></a>

# TypeCompiler

Version 1.0 makes API changes to the TypeBox compiler but retains the same functionality. The biggest change in 1.0 is the renaming of TypeCheck to Validator. Implementations that reference TypeCheck will need to updated reference Validator. Additionally, the TypeCompiler namespace has been deprecated, implementations can now use the Compile function exported on the submodule.

## Example

0.34.x

```typescript
import { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'

const C = TypeCompiler.Compile(Type.String())       // TypeCheck<TString>

C.Check('hello') // true
```

1.0.0

```typescript
import { Compile, Validator } from 'typebox/compile'

const C = Compile(Type.String())                    // Validator<{}, TString>

C.Check('hello') // true
```

<a name="References"></a>

# References

Version 1.0 introduces a model for handling referential types. This model is reflected across Value and Compiler submodules. In 1.0, references are new passed via a optional Context object. This replaces the `references` array in 0.34.x. 

## Example

0.34.x

```typescript
const A = Type.String({ $id: 'A' })
const B = Type.Number({ $id: 'B' })

const T = Type.Object({
  a: Type.Unsafe<Static<typeof A>>(Type.Ref('A')),  // Unsafe Static for Inference
  b: Type.Unsafe<Static<typeof B>>(Type.Ref('B')),
})

const C = TypeCompiler.Compile(T, [A, B])           // References Array

const R = C.Decode({ a: '', b: 1 })                 // const R: { a: string, b: number }
```

1.0.0

```typescript
const A = Type.String()
const B = Type.Number()

const T = Type.Object({
  a: Type.Ref('A'),
  b: Type.Ref('B')
})

const C = Compile({ A, B }, T)                      // const R: { a: string, b: number }
```

<a name="FormatRegistry"></a>

# FormatRegistry

TypeBox 1.0 moves the FormatRegistry to the Format submodule.

## Example

0.34.x

```typescript
import { FormatRegistry } from '@sinclair/typebox'

FormatRegistry.Set('foo', value => value === 'foo')
```

1.0.0

```typescript
import { FormatRegistry } from 'typebox/format'

FormatRegistry.Set('foo', value => value === 'foo')
```

<a name="TypeRegistry"></a>

# TypeRegistry

TypeBox 1.0 removes the TypeRegistry. This registry has been replaced by Type.Base that enables custom types to be created without the need for registration. The Base type provides the same capabilities as the TypeRegistry but is structured quite differently. The example comments show the changes.

## Example

0.34.x

```typescript
import { TypeRegistry, Kind, TSchema } from '@sinclair/typebox'

// Definition
interface TFoo extends TSchema {
  [Kind]: 'Foo'  
  static: 'Foo'  // Static
}
// Check
TypeRegistry.Set('Foo', (value) => value === 'Foo')

// Factory
function Foo(): TFoo {
  return { [Kind]: 'Foo' } as never
}

```

1.0.0

```typescript
import Type from '@sinclair/typebox'

// Definition
export class TFoo extends Type.Base<'Foo'> { // Static
  // Check
  public override Check(value: unknown): value is 'Foo' {
    return value === 'Foo'
  }
}
// Factory
export function Foo(): TDate {
  return new TDate()
}
```


<a name="TypeGuard"></a>

# TypeGuard

TypeBox 1.0 removes the TypeGuard. The `Is` functions have been moved to `Type.*`.

## Example

0.34.x

```typescript
import { Type, TypeGuard } from '@sinclair/typebox'

const T = Type.String()

const R = TypeGuard.IsString(T)                     // const R = true
```

1.0.0

```typescript
import Type from 'typebox'

const T = Type.String()

const R = Type.IsString(T)                          // const R = true
```

<a name="Errors"></a>

# Value.Errors

Version 1.0 changes the Errors() return type from Iterator to Array. It also updates the Error to be inline with Ajv. This change enables TypeBox errors to integrate with existing systems that report errors using the Ajv structure. Existing applications will need to update error handling inline with the new structure.

## Error Interface

0.34.x

```typescript
export interface ValueError {
  type: ValueErrorType
  schema: TSchema
  path: string
  value: unknown
  message: string
  errors: ValueErrorIterator[]
}
```

1.0.0

```typescript
interface TLocalizedValidationError {
  keyword: string
  schemaPath: string
  instancePath: string
  params: object
  messge: string
}
```

## Example

0.34.x

```typescript
import { Value } from '@sinclair/typebox/value'

const T = Type.Number()

const E = [...Value.Errors(T, 'not a number')]      // IterableIterator<Error>
```

1.0.0

```typescript
import Value from 'typebox/value'

const T = Type.Number()

const E = Value.Errors(T, 'not a number')            // TLocalizedValidationError[]
```

<a name="Cast"></a>

# Value.Cast

Version 1.0 renames Cast to Repair.

## Example

0.34.x

```typescript
const T = Type.Object({ x: Type.Number() })

const R = Value.Cast(T, { })                        // const R = { x: 0 }
```

1.0.0

```typescript
const T = Type.Object({ x: Type.Number() })

const R = Value.Repair(T, { })                        // const R = { x: 0 }
```