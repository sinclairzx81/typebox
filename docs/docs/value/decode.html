<h1>Value.Decode</h1>
<p>The Decode function will execute Decode callbacks embedded within the provided type. </p>
<blockquote>
<p>⚠️ This function may throw an error if the provided value is invalid or if a failure occurs during the decoding process. It is recommended to wrap this function in a try / catch block.</p>
</blockquote>
<h2>Example</h2>
<p>Example usage is shown below.</p>
<pre><code class="language-typescript">const Timestamp = Type.Codec(Type.Number())
  .Decode(value =&gt; new Date(value))                 
  .Encode(value =&gt; value.getTime())

const T = Type.Object({
  date: Timestamp
})

const R = Value.Decode(T, { date: 12345 })          // const R = {
                                                    //   date: 1970-01-01T00:00:12.345Z
                                                    // }
</code></pre>
<h2>Pipeline</h2>
<p>The Decode function uses the following Decoder pipeline.</p>
<pre><code class="language-typescript">const Decoder = Pipeline([
  (_context, _type, value) =&gt; Clone(value),
  (context, type, value) =&gt; Default(context, type, value),
  (context, type, value) =&gt; Convert(context, type, value),
  (context, type, value) =&gt; Clean(context, type, value),
  (context, type, value) =&gt; Assert(context, type, value),
  (context, type, value) =&gt; DecodeUnsafe(context, type, value) // &lt;--- Decode Last
])
</code></pre>
<h2>Unsafe</h2>
<p>The Decode function runs the full decoder pipeline to ensure Codec callbacks receive validated values. In some cases, applications may require greater control, for example, to optimize performance or integrate with functions beyond what is offered by TypeBox. For these scenarios, the Value module provides the DecodeUnsafe function, which executes Codec callbacks directly without additional processing. </p>
<blockquote>
<p> ⚠️ The DecodeUnsafe function returns unknown and provides no assurances the decoded value is valid. Callers must handle validation and inference manually. This is usually achieved by wrapping a pipeline in a generic function constrained by a TypeBox type.</p>
</blockquote>
<p>The example below defines a reduced decoder that runs only Assert and Codec callbacks.</p>
<pre><code class="language-typescript">
import { Pipeline, Assert, DecodeUnsafe } from &#39;typebox/value&#39;

// CustomDecoder

const CustomDecoder = Pipeline([
  (context, type, value) =&gt; { Assert(context, type, value); return value },
  (context, type, value) =&gt; DecodeUnsafe(context, type, value)
])

// Type + Decode

const NumberToString = Type.Decode(Type.Number(), value =&gt; value.toString())

// Result

const Result = CustomDecoder(NumberToString, 123456) // const Result: unknown = &quot;123456&quot;
</code></pre>
