import { TypeGuard } from '@sinclair/typebox'
import { Type } from '@sinclair/typebox'
import { Assert } from '../../assert/index'

describe('type/guard/TDeref', () => {
  it('Should should deref 1', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const D = Type.Deref(R, [T])
    Assert.IsTrue(TypeGuard.TString(D))
    Assert.IsFalse('$id' in D)
  })
  it('Should should deref 2', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.Object({
      x: R,
      y: R,
    })
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TObject(D))
    Assert.IsTrue(TypeGuard.TString(D.properties.x))
    Assert.IsTrue(TypeGuard.TString(D.properties.y))
    Assert.IsFalse('$id' in D.properties.x)
    Assert.IsFalse('$id' in D.properties.y)
  })
  it('Should should deref 3', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.Array(R)
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TArray(D))
    Assert.IsTrue(TypeGuard.TString(D.items))
    Assert.IsFalse('$id' in D.items)
  })
  it('Should should deref 4', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.AsyncIterator(R)
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TAsyncIterator(D))
    Assert.IsTrue(TypeGuard.TString(D.items))
    Assert.IsFalse('$id' in D.items)
  })
  it('Should should deref 5', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.Iterator(R)
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TIterator(D))
    Assert.IsTrue(TypeGuard.TString(D.items))
    Assert.IsFalse('$id' in D.items)
  })
  it('Should should deref 6', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.Function([R], R)
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TFunction(D))
    Assert.IsTrue(TypeGuard.TString(D.parameters[0]))
    Assert.IsTrue(TypeGuard.TString(D.returns))
    Assert.IsFalse('$id' in D.parameters[0])
    Assert.IsFalse('$id' in D.returns)
  })
  it('Should should deref 7', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.Constructor([R], R)
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TConstructor(D))
    Assert.IsTrue(TypeGuard.TString(D.parameters[0]))
    Assert.IsTrue(TypeGuard.TString(D.returns))
    Assert.IsFalse('$id' in D.parameters[0])
    Assert.IsFalse('$id' in D.returns)
  })
  it('Should should deref 8', () => {
    const T = Type.String({ $id: 'T' })
    const R = Type.Ref(T)
    const O = Type.Promise(R)
    const D = Type.Deref(O, [T])
    Assert.IsTrue(TypeGuard.TPromise(D))
    Assert.IsTrue(TypeGuard.TString(D.item))
    Assert.IsFalse('$id' in D.item)
  })
  it('Should should deref 9', () => {
    const T = Type.String({ $id: 'T' })
    const R1 = Type.Ref(T, { $id: 'R1' })
    const R2 = Type.Ref(R1, { $id: 'R2' })
    const R3 = Type.Ref(R2, { $id: 'R3' })
    const R4 = Type.Ref(R3, { $id: 'R4' })
    const R5 = Type.Ref(R4, { $id: 'R5' })
    const R6 = Type.Ref(R5, { $id: 'R6' })
    const O = Type.Array(R6)
    const D = Type.Deref(O, [R6, R5, R4, R3, R2, R1, T])
    Assert.IsTrue(TypeGuard.TArray(D))
    Assert.IsTrue(TypeGuard.TString(D.items))
    Assert.IsFalse('$id' in D.items)
  })
  it('Should should deref 10', () => {
    const T = Type.String({ $id: 'T' })
    const R1 = Type.Ref(T, { $id: 'R1' })
    const R2 = Type.Ref(R1, { $id: 'R2' })
    const R3 = Type.Ref(R2, { $id: 'R3' })
    const R4 = Type.Ref(R3, { $id: 'R4' })
    const R5 = Type.Ref(R4, { $id: 'R5' })
    const R6 = Type.Ref(R5, { $id: 'R6' })
    const O = Type.Array(R6)
    Assert.Throws(() => Type.Deref(O, [R6, R5, R4, R3, R2, R1])) // Omit T
  })
})
