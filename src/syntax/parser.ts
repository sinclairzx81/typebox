/*--------------------------------------------------------------------------

@sinclair/typebox/syntax

The MIT License (MIT)

Copyright (c) 2017-2025 Haydn Paterson (sinclair) <haydn.developer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

---------------------------------------------------------------------------*/

import { Runtime, Static } from '../parser/index'
import * as T from '../type/index'
import * as S from './mapping'

// ------------------------------------------------------------------
// Parser
//
// The following code is optimized inline types generated by a remote
// compiler process. It is readonly and should not be modified.
// ------------------------------------------------------------------

export type TGenericReferenceParameterList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (
  TType<Input, Context> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0, infer Input extends string]
  ? TGenericReferenceParameterList_0<Input, Context, [...Result, _0]>
  : [Result, Input]
export type TGenericReferenceParameterList<Input extends string, Context extends T.TProperties = {}> = (
  TGenericReferenceParameterList_0<Input, Context> extends [infer _0, infer Input extends string]
    ? (
        (TType<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []
      ) extends [infer _1, infer Input extends string]
      ? [[_0, _1], Input]
      : []
    : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TGenericReferenceParameterListMapping<_0, Context>, Input]
  : []
export type TGenericReference<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Ident<Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TGenericReferenceParameterList<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TGenericReferenceMapping<_0, Context>, Input]
  : []
export type TGenericArgumentsList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (
  Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0, infer Input extends string]
  ? TGenericArgumentsList_0<Input, Context, [...Result, _0]>
  : [Result, Input]
export type TGenericArgumentsList<Input extends string, Context extends T.TProperties = {}> = (
  TGenericArgumentsList_0<Input, Context> extends [infer _0, infer Input extends string]
    ? (
        (Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
          ? [_0, Input]
          : [[], Input] extends [infer _0, infer Input extends string]
          ? [_0, Input]
          : []
      ) extends [infer _1, infer Input extends string]
      ? [[_0, _1], Input]
      : []
    : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TGenericArgumentsListMapping<_0, Context>, Input]
  : []
export type TGenericArguments<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'<', Input> extends [infer _0, infer Input extends string]
    ? TGenericArgumentsList<Input, Context> extends [infer _1, infer Input extends string]
      ? Static.Token.Const<'>', Input> extends [infer _2, infer Input extends string]
        ? [[_0, _1, _2], Input]
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string]
  ? [S.TGenericArgumentsMapping<_0, Context>, Input]
  : []
export type TKeywordString<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'string', Input> extends [infer _0 extends 'string', infer Input extends string] ? [S.TKeywordStringMapping<_0, Context>, Input] : []
export type TKeywordNumber<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'number', Input> extends [infer _0 extends 'number', infer Input extends string] ? [S.TKeywordNumberMapping<_0, Context>, Input] : []
export type TKeywordBoolean<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'boolean', Input> extends [infer _0 extends 'boolean', infer Input extends string]
  ? [S.TKeywordBooleanMapping<_0, Context>, Input]
  : []
export type TKeywordUndefined<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'undefined', Input> extends [infer _0 extends 'undefined', infer Input extends string]
  ? [S.TKeywordUndefinedMapping<_0, Context>, Input]
  : []
export type TKeywordNull<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'null', Input> extends [infer _0 extends 'null', infer Input extends string] ? [S.TKeywordNullMapping<_0, Context>, Input] : []
export type TKeywordInteger<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'integer', Input> extends [infer _0 extends 'integer', infer Input extends string]
  ? [S.TKeywordIntegerMapping<_0, Context>, Input]
  : []
export type TKeywordBigInt<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'bigint', Input> extends [infer _0 extends 'bigint', infer Input extends string] ? [S.TKeywordBigIntMapping<_0, Context>, Input] : []
export type TKeywordUnknown<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'unknown', Input> extends [infer _0 extends 'unknown', infer Input extends string]
  ? [S.TKeywordUnknownMapping<_0, Context>, Input]
  : []
export type TKeywordAny<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'any', Input> extends [infer _0 extends 'any', infer Input extends string] ? [S.TKeywordAnyMapping<_0, Context>, Input] : []
export type TKeywordNever<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'never', Input> extends [infer _0 extends 'never', infer Input extends string] ? [S.TKeywordNeverMapping<_0, Context>, Input] : []
export type TKeywordSymbol<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'symbol', Input> extends [infer _0 extends 'symbol', infer Input extends string] ? [S.TKeywordSymbolMapping<_0, Context>, Input] : []
export type TKeywordVoid<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'void', Input> extends [infer _0 extends 'void', infer Input extends string] ? [S.TKeywordVoidMapping<_0, Context>, Input] : []
export type TKeyword<Input extends string, Context extends T.TProperties = {}> = (
  TKeywordString<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordNumber<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordBoolean<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordUndefined<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordNull<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordInteger<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordBigInt<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordUnknown<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordAny<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordNever<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordSymbol<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeywordVoid<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends unknown, infer Input extends string]
  ? [S.TKeywordMapping<_0, Context>, Input]
  : []
export type TLiteralString<Input extends string, Context extends T.TProperties = {}> = Static.Token.String<["'", '"', '`'], Input> extends [infer _0 extends string, infer Input extends string]
  ? [S.TLiteralStringMapping<_0, Context>, Input]
  : []
export type TLiteralNumber<Input extends string, Context extends T.TProperties = {}> = Static.Token.Number<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TLiteralNumberMapping<_0, Context>, Input] : []
export type TLiteralBoolean<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'true', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : Static.Token.Const<'false', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []
) extends [infer _0 extends 'true' | 'false', infer Input extends string]
  ? [S.TLiteralBooleanMapping<_0, Context>, Input]
  : []
export type TLiteral<Input extends string, Context extends T.TProperties = {}> = (
  TLiteralBoolean<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TLiteralNumber<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TLiteralString<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends unknown, infer Input extends string]
  ? [S.TLiteralMapping<_0, Context>, Input]
  : []
export type TKeyOf<Input extends string, Context extends T.TProperties = {}> = (
  (Static.Token.Const<'keyof', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : [[], Input] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown] | [], infer Input extends string]
  ? [S.TKeyOfMapping<_0, Context>, Input]
  : []
export type TIndexArray_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (
  (
    Static.Token.Const<'[', Input> extends [infer _0, infer Input extends string]
      ? TType<Input, Context> extends [infer _1, infer Input extends string]
        ? Static.Token.Const<']', Input> extends [infer _2, infer Input extends string]
          ? [[_0, _1, _2], Input]
          : []
        : []
      : []
  ) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : (Static.Token.Const<'[', Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<']', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [
        infer _0,
        infer Input extends string,
      ]
    ? [_0, Input]
    : []
) extends [infer _0, infer Input extends string]
  ? TIndexArray_0<Input, Context, [...Result, _0]>
  : [Result, Input]
export type TIndexArray<Input extends string, Context extends T.TProperties = {}> = TIndexArray_0<Input, Context> extends [infer _0 extends ([unknown, unknown, unknown] | [unknown, unknown])[], infer Input extends string]
  ? [S.TIndexArrayMapping<_0, Context>, Input]
  : []
export type TExtends<Input extends string, Context extends T.TProperties = {}> = (
  (
    Static.Token.Const<'extends', Input> extends [infer _0, infer Input extends string]
      ? TType<Input, Context> extends [infer _1, infer Input extends string]
        ? Static.Token.Const<'?', Input> extends [infer _2, infer Input extends string]
          ? TType<Input, Context> extends [infer _3, infer Input extends string]
            ? Static.Token.Const<':', Input> extends [infer _4, infer Input extends string]
              ? TType<Input, Context> extends [infer _5, infer Input extends string]
                ? [[_0, _1, _2, _3, _4, _5], Input]
                : []
              : []
            : []
          : []
        : []
      : []
  ) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : [[], Input] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown] | [], infer Input extends string]
  ? [S.TExtendsMapping<_0, Context>, Input]
  : []
export type TBase<Input extends string, Context extends T.TProperties = {}> = (
  (
    Static.Token.Const<'(', Input> extends [infer _0, infer Input extends string]
      ? TType<Input, Context> extends [infer _1, infer Input extends string]
        ? Static.Token.Const<')', Input> extends [infer _2, infer Input extends string]
          ? [[_0, _1, _2], Input]
          : []
        : []
      : []
  ) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TKeyword<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TObject<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TTuple<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TLiteral<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TConstructor<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TFunction<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TMapped<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TAsyncIterator<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TIterator<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TConstructorParameters<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TFunctionParameters<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TInstanceType<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TReturnType<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TArgument<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TAwaited<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TArray<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TRecord<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TPromise<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TPartial<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TRequired<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TPick<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TOmit<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TExclude<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TExtract<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TUppercase<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TLowercase<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TCapitalize<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TUncapitalize<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TDate<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TUint8Array<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TGenericReference<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TReference<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown, unknown, unknown] | unknown, infer Input extends string]
  ? [S.TBaseMapping<_0, Context>, Input]
  : []
export type TFactor<Input extends string, Context extends T.TProperties = {}> = (
  TKeyOf<Input, Context> extends [infer _0, infer Input extends string]
    ? TBase<Input, Context> extends [infer _1, infer Input extends string]
      ? TIndexArray<Input, Context> extends [infer _2, infer Input extends string]
        ? TExtends<Input, Context> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TFactorMapping<_0, Context>, Input]
  : []
export type TExprTermTail<Input extends string, Context extends T.TProperties = {}> = (
  (
    Static.Token.Const<'&', Input> extends [infer _0, infer Input extends string]
      ? TFactor<Input, Context> extends [infer _1, infer Input extends string]
        ? TExprTermTail<Input, Context> extends [infer _2, infer Input extends string]
          ? [[_0, _1, _2], Input]
          : []
        : []
      : []
  ) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : [[], Input] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown, unknown, unknown] | [], infer Input extends string]
  ? [S.TExprTermTailMapping<_0, Context>, Input]
  : []
export type TExprTerm<Input extends string, Context extends T.TProperties = {}> = (
  TFactor<Input, Context> extends [infer _0, infer Input extends string] ? (TExprTermTail<Input, Context> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TExprTermMapping<_0, Context>, Input]
  : []
export type TExprTail<Input extends string, Context extends T.TProperties = {}> = (
  (
    Static.Token.Const<'|', Input> extends [infer _0, infer Input extends string]
      ? TExprTerm<Input, Context> extends [infer _1, infer Input extends string]
        ? TExprTail<Input, Context> extends [infer _2, infer Input extends string]
          ? [[_0, _1, _2], Input]
          : []
        : []
      : []
  ) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : [[], Input] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown, unknown, unknown] | [], infer Input extends string]
  ? [S.TExprTailMapping<_0, Context>, Input]
  : []
export type TExpr<Input extends string, Context extends T.TProperties = {}> = (
  TExprTerm<Input, Context> extends [infer _0, infer Input extends string] ? (TExprTail<Input, Context> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TExprMapping<_0, Context>, Input]
  : []
export type TType<Input extends string, Context extends T.TProperties = {}> = (
  TGenericArguments<Input, Context> extends [infer _0 extends T.TProperties, infer Input extends string]
    ? TExpr<Input, _0>
    : [] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : TExpr<Input, Context> extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends unknown, infer Input extends string]
  ? [S.TTypeMapping<_0, Context>, Input]
  : []
export type TPropertyKey<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Ident<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : Static.Token.String<["'", '"'], Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []
) extends [infer _0 extends string, infer Input extends string]
  ? [S.TPropertyKeyMapping<_0, Context>, Input]
  : []
export type TReadonly<Input extends string, Context extends T.TProperties = {}> = (
  (Static.Token.Const<'readonly', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : [[], Input] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown] | [], infer Input extends string]
  ? [S.TReadonlyMapping<_0, Context>, Input]
  : []
export type TOptional<Input extends string, Context extends T.TProperties = {}> = (
  (Static.Token.Const<'?', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : [[], Input] extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown] | [], infer Input extends string]
  ? [S.TOptionalMapping<_0, Context>, Input]
  : []
export type TProperty<Input extends string, Context extends T.TProperties = {}> = (
  TReadonly<Input, Context> extends [infer _0, infer Input extends string]
    ? TPropertyKey<Input, Context> extends [infer _1, infer Input extends string]
      ? TOptional<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<':', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? [[_0, _1, _2, _3, _4], Input]
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TPropertyMapping<_0, Context>, Input]
  : []
export type TPropertyDelimiter<Input extends string, Context extends T.TProperties = {}> = (
  (Static.Token.Const<',', Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [
    infer _0,
    infer Input extends string,
  ]
    ? [_0, Input]
    : (Static.Token.Const<';', Input> extends [infer _0, infer Input extends string] ? (Static.Token.Const<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [
        infer _0,
        infer Input extends string,
      ]
    ? [_0, Input]
    : (Static.Token.Const<',', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : (Static.Token.Const<';', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : (Static.Token.Const<'\n', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
    ? [_0, Input]
    : []
) extends [infer _0 extends [unknown, unknown] | [unknown], infer Input extends string]
  ? [S.TPropertyDelimiterMapping<_0, Context>, Input]
  : []
export type TPropertyList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (
  TProperty<Input, Context> extends [infer _0, infer Input extends string] ? (TPropertyDelimiter<Input, Context> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0, infer Input extends string]
  ? TPropertyList_0<Input, Context, [...Result, _0]>
  : [Result, Input]
export type TPropertyList<Input extends string, Context extends T.TProperties = {}> = (
  TPropertyList_0<Input, Context> extends [infer _0, infer Input extends string]
    ? (
        (TProperty<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
          ? [_0, Input]
          : [[], Input] extends [infer _0, infer Input extends string]
          ? [_0, Input]
          : []
      ) extends [infer _1, infer Input extends string]
      ? [[_0, _1], Input]
      : []
    : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TPropertyListMapping<_0, Context>, Input]
  : []
export type TObject<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'{', Input> extends [infer _0, infer Input extends string]
    ? TPropertyList<Input, Context> extends [infer _1, infer Input extends string]
      ? Static.Token.Const<'}', Input> extends [infer _2, infer Input extends string]
        ? [[_0, _1, _2], Input]
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string]
  ? [S.TObjectMapping<_0, Context>, Input]
  : []
export type TElementList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (
  TType<Input, Context> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0, infer Input extends string]
  ? TElementList_0<Input, Context, [...Result, _0]>
  : [Result, Input]
export type TElementList<Input extends string, Context extends T.TProperties = {}> = (
  TElementList_0<Input, Context> extends [infer _0, infer Input extends string]
    ? (
        (TType<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []
      ) extends [infer _1, infer Input extends string]
      ? [[_0, _1], Input]
      : []
    : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TElementListMapping<_0, Context>, Input]
  : []
export type TTuple<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'[', Input> extends [infer _0, infer Input extends string]
    ? TElementList<Input, Context> extends [infer _1, infer Input extends string]
      ? Static.Token.Const<']', Input> extends [infer _2, infer Input extends string]
        ? [[_0, _1, _2], Input]
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string]
  ? [S.TTupleMapping<_0, Context>, Input]
  : []
export type TParameter<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Ident<Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<':', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? [[_0, _1, _2], Input]
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string]
  ? [S.TParameterMapping<_0, Context>, Input]
  : []
export type TParameterList_0<Input extends string, Context extends T.TProperties, Result extends unknown[] = []> = (
  TParameter<Input, Context> extends [infer _0, infer Input extends string] ? (Static.Token.Const<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []
) extends [infer _0, infer Input extends string]
  ? TParameterList_0<Input, Context, [...Result, _0]>
  : [Result, Input]
export type TParameterList<Input extends string, Context extends T.TProperties = {}> = (
  TParameterList_0<Input, Context> extends [infer _0, infer Input extends string]
    ? (
        (TParameter<Input, Context> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string]
          ? [_0, Input]
          : [[], Input] extends [infer _0, infer Input extends string]
          ? [_0, Input]
          : []
      ) extends [infer _1, infer Input extends string]
      ? [[_0, _1], Input]
      : []
    : []
) extends [infer _0 extends [unknown, unknown], infer Input extends string]
  ? [S.TParameterListMapping<_0, Context>, Input]
  : []
export type TFunction<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'(', Input> extends [infer _0, infer Input extends string]
    ? TParameterList<Input, Context> extends [infer _1, infer Input extends string]
      ? Static.Token.Const<')', Input> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'=>', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? [[_0, _1, _2, _3, _4], Input]
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TFunctionMapping<_0, Context>, Input]
  : []
export type TConstructor<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'new', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'(', Input> extends [infer _1, infer Input extends string]
      ? TParameterList<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<')', Input> extends [infer _3, infer Input extends string]
          ? Static.Token.Const<'=>', Input> extends [infer _4, infer Input extends string]
            ? TType<Input, Context> extends [infer _5, infer Input extends string]
              ? [[_0, _1, _2, _3, _4, _5], Input]
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TConstructorMapping<_0, Context>, Input]
  : []
export type TMapped<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'{', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'[', Input> extends [infer _1, infer Input extends string]
      ? Static.Token.Ident<Input> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'in', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? Static.Token.Const<']', Input> extends [infer _5, infer Input extends string]
              ? Static.Token.Const<':', Input> extends [infer _6, infer Input extends string]
                ? TType<Input, Context> extends [infer _7, infer Input extends string]
                  ? Static.Token.Const<'}', Input> extends [infer _8, infer Input extends string]
                    ? [[_0, _1, _2, _3, _4, _5, _6, _7, _8], Input]
                    : []
                  : []
                : []
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TMappedMapping<_0, Context>, Input]
  : []
export type TAsyncIterator<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'AsyncIterator', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TAsyncIteratorMapping<_0, Context>, Input]
  : []
export type TIterator<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Iterator', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TIteratorMapping<_0, Context>, Input]
  : []
export type TArgument<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Argument', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TArgumentMapping<_0, Context>, Input]
  : []
export type TAwaited<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Awaited', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TAwaitedMapping<_0, Context>, Input]
  : []
export type TArray<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Array', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TArrayMapping<_0, Context>, Input]
  : []
export type TRecord<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Record', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string]
              ? [[_0, _1, _2, _3, _4, _5], Input]
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TRecordMapping<_0, Context>, Input]
  : []
export type TPromise<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Promise', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TPromiseMapping<_0, Context>, Input]
  : []
export type TConstructorParameters<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'ConstructorParameters', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TConstructorParametersMapping<_0, Context>, Input]
  : []
export type TFunctionParameters<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Parameters', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TFunctionParametersMapping<_0, Context>, Input]
  : []
export type TInstanceType<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'InstanceType', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TInstanceTypeMapping<_0, Context>, Input]
  : []
export type TReturnType<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'ReturnType', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TReturnTypeMapping<_0, Context>, Input]
  : []
export type TPartial<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Partial', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TPartialMapping<_0, Context>, Input]
  : []
export type TRequired<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Required', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TRequiredMapping<_0, Context>, Input]
  : []
export type TPick<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Pick', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string]
              ? [[_0, _1, _2, _3, _4, _5], Input]
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TPickMapping<_0, Context>, Input]
  : []
export type TOmit<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Omit', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string]
              ? [[_0, _1, _2, _3, _4, _5], Input]
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TOmitMapping<_0, Context>, Input]
  : []
export type TExclude<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Exclude', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string]
              ? [[_0, _1, _2, _3, _4, _5], Input]
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TExcludeMapping<_0, Context>, Input]
  : []
export type TExtract<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Extract', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<',', Input> extends [infer _3, infer Input extends string]
          ? TType<Input, Context> extends [infer _4, infer Input extends string]
            ? Static.Token.Const<'>', Input> extends [infer _5, infer Input extends string]
              ? [[_0, _1, _2, _3, _4, _5], Input]
              : []
            : []
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TExtractMapping<_0, Context>, Input]
  : []
export type TUppercase<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Uppercase', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TUppercaseMapping<_0, Context>, Input]
  : []
export type TLowercase<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Lowercase', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TLowercaseMapping<_0, Context>, Input]
  : []
export type TCapitalize<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Capitalize', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TCapitalizeMapping<_0, Context>, Input]
  : []
export type TUncapitalize<Input extends string, Context extends T.TProperties = {}> = (
  Static.Token.Const<'Uncapitalize', Input> extends [infer _0, infer Input extends string]
    ? Static.Token.Const<'<', Input> extends [infer _1, infer Input extends string]
      ? TType<Input, Context> extends [infer _2, infer Input extends string]
        ? Static.Token.Const<'>', Input> extends [infer _3, infer Input extends string]
          ? [[_0, _1, _2, _3], Input]
          : []
        : []
      : []
    : []
) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string]
  ? [S.TUncapitalizeMapping<_0, Context>, Input]
  : []
export type TDate<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'Date', Input> extends [infer _0 extends 'Date', infer Input extends string] ? [S.TDateMapping<_0, Context>, Input] : []
export type TUint8Array<Input extends string, Context extends T.TProperties = {}> = Static.Token.Const<'Uint8Array', Input> extends [infer _0 extends 'Uint8Array', infer Input extends string]
  ? [S.TUint8ArrayMapping<_0, Context>, Input]
  : []
export type TReference<Input extends string, Context extends T.TProperties = {}> = Static.Token.Ident<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TReferenceMapping<_0, Context>, Input] : []
const If = (result: [unknown, string] | [], left: (input: [unknown, string]) => [unknown, string] | [], right: () => [unknown, string] | [] = () => []): [unknown, string] | [] => (result.length === 2 ? left(result) : right())

export const GenericReferenceParameterList_0 = (input: string, context: T.TProperties, result: unknown[] = []): [unknown[], string] =>
  If(
    If(Type(input, context), ([_0, input]) => If(Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => GenericReferenceParameterList_0(input, context, [...result, _0]),
    () => [result, input],
  ) as [unknown[], string]
export const GenericReferenceParameterList = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(GenericReferenceParameterList_0(input, context), ([_0, input]) =>
      If(
        If(
          If(Type(input, context), ([_0, input]) => [[_0], input]),
          ([_0, input]) => [_0, input],
          () =>
            If(
              [[], input],
              ([_0, input]) => [_0, input],
              () => [],
            ),
        ),
        ([_1, input]) => [[_0, _1], input],
      ),
    ),
    ([_0, input]) => [S.GenericReferenceParameterListMapping(_0 as [unknown, unknown], context), input],
  )
export const GenericReference = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Ident(input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(GenericReferenceParameterList(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.GenericReferenceMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const GenericArgumentsList_0 = (input: string, context: T.TProperties, result: unknown[] = []): [unknown[], string] =>
  If(
    If(Runtime.Token.Ident(input), ([_0, input]) => If(Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => GenericArgumentsList_0(input, context, [...result, _0]),
    () => [result, input],
  ) as [unknown[], string]
export const GenericArgumentsList = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(GenericArgumentsList_0(input, context), ([_0, input]) =>
      If(
        If(
          If(Runtime.Token.Ident(input), ([_0, input]) => [[_0], input]),
          ([_0, input]) => [_0, input],
          () =>
            If(
              [[], input],
              ([_0, input]) => [_0, input],
              () => [],
            ),
        ),
        ([_1, input]) => [[_0, _1], input],
      ),
    ),
    ([_0, input]) => [S.GenericArgumentsListMapping(_0 as [unknown, unknown], context), input],
  )
export const GenericArguments = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('<', input), ([_0, input]) => If(GenericArgumentsList(input, context), ([_1, input]) => If(Runtime.Token.Const('>', input), ([_2, input]) => [[_0, _1, _2], input]))),
    ([_0, input]) => [S.GenericArgumentsMapping(_0 as [unknown, unknown, unknown], context), input],
  )
export const KeywordString = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('string', input), ([_0, input]) => [S.KeywordStringMapping(_0 as 'string', context), input])
export const KeywordNumber = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('number', input), ([_0, input]) => [S.KeywordNumberMapping(_0 as 'number', context), input])
export const KeywordBoolean = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('boolean', input), ([_0, input]) => [S.KeywordBooleanMapping(_0 as 'boolean', context), input])
export const KeywordUndefined = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('undefined', input), ([_0, input]) => [S.KeywordUndefinedMapping(_0 as 'undefined', context), input])
export const KeywordNull = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('null', input), ([_0, input]) => [S.KeywordNullMapping(_0 as 'null', context), input])
export const KeywordInteger = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('integer', input), ([_0, input]) => [S.KeywordIntegerMapping(_0 as 'integer', context), input])
export const KeywordBigInt = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('bigint', input), ([_0, input]) => [S.KeywordBigIntMapping(_0 as 'bigint', context), input])
export const KeywordUnknown = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('unknown', input), ([_0, input]) => [S.KeywordUnknownMapping(_0 as 'unknown', context), input])
export const KeywordAny = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('any', input), ([_0, input]) => [S.KeywordAnyMapping(_0 as 'any', context), input])
export const KeywordNever = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('never', input), ([_0, input]) => [S.KeywordNeverMapping(_0 as 'never', context), input])
export const KeywordSymbol = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('symbol', input), ([_0, input]) => [S.KeywordSymbolMapping(_0 as 'symbol', context), input])
export const KeywordVoid = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('void', input), ([_0, input]) => [S.KeywordVoidMapping(_0 as 'void', context), input])
export const Keyword = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      KeywordString(input, context),
      ([_0, input]) => [_0, input],
      () =>
        If(
          KeywordNumber(input, context),
          ([_0, input]) => [_0, input],
          () =>
            If(
              KeywordBoolean(input, context),
              ([_0, input]) => [_0, input],
              () =>
                If(
                  KeywordUndefined(input, context),
                  ([_0, input]) => [_0, input],
                  () =>
                    If(
                      KeywordNull(input, context),
                      ([_0, input]) => [_0, input],
                      () =>
                        If(
                          KeywordInteger(input, context),
                          ([_0, input]) => [_0, input],
                          () =>
                            If(
                              KeywordBigInt(input, context),
                              ([_0, input]) => [_0, input],
                              () =>
                                If(
                                  KeywordUnknown(input, context),
                                  ([_0, input]) => [_0, input],
                                  () =>
                                    If(
                                      KeywordAny(input, context),
                                      ([_0, input]) => [_0, input],
                                      () =>
                                        If(
                                          KeywordNever(input, context),
                                          ([_0, input]) => [_0, input],
                                          () =>
                                            If(
                                              KeywordSymbol(input, context),
                                              ([_0, input]) => [_0, input],
                                              () =>
                                                If(
                                                  KeywordVoid(input, context),
                                                  ([_0, input]) => [_0, input],
                                                  () => [],
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        ),
    ),
    ([_0, input]) => [S.KeywordMapping(_0 as unknown, context), input],
  )
export const LiteralString = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.String(["'", '"', '`'], input), ([_0, input]) => [S.LiteralStringMapping(_0 as string, context), input])
export const LiteralNumber = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Number(input), ([_0, input]) => [S.LiteralNumberMapping(_0 as string, context), input])
export const LiteralBoolean = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      Runtime.Token.Const('true', input),
      ([_0, input]) => [_0, input],
      () =>
        If(
          Runtime.Token.Const('false', input),
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.LiteralBooleanMapping(_0 as 'true' | 'false', context), input],
  )
export const Literal = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      LiteralBoolean(input, context),
      ([_0, input]) => [_0, input],
      () =>
        If(
          LiteralNumber(input, context),
          ([_0, input]) => [_0, input],
          () =>
            If(
              LiteralString(input, context),
              ([_0, input]) => [_0, input],
              () => [],
            ),
        ),
    ),
    ([_0, input]) => [S.LiteralMapping(_0 as unknown, context), input],
  )
export const KeyOf = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('keyof', input), ([_0, input]) => [[_0], input]),
      ([_0, input]) => [_0, input],
      () =>
        If(
          [[], input],
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.KeyOfMapping(_0 as [unknown] | [], context), input],
  )
export const IndexArray_0 = (input: string, context: T.TProperties, result: unknown[] = []): [unknown[], string] =>
  If(
    If(
      If(Runtime.Token.Const('[', input), ([_0, input]) => If(Type(input, context), ([_1, input]) => If(Runtime.Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))),
      ([_0, input]) => [_0, input],
      () =>
        If(
          If(Runtime.Token.Const('[', input), ([_0, input]) => If(Runtime.Token.Const(']', input), ([_1, input]) => [[_0, _1], input])),
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => IndexArray_0(input, context, [...result, _0]),
    () => [result, input],
  ) as [unknown[], string]
export const IndexArray = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(IndexArray_0(input, context), ([_0, input]) => [S.IndexArrayMapping(_0 as ([unknown, unknown, unknown] | [unknown, unknown])[], context), input])
export const Extends = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('extends', input), ([_0, input]) =>
        If(Type(input, context), ([_1, input]) =>
          If(Runtime.Token.Const('?', input), ([_2, input]) => If(Type(input, context), ([_3, input]) => If(Runtime.Token.Const(':', input), ([_4, input]) => If(Type(input, context), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))),
        ),
      ),
      ([_0, input]) => [_0, input],
      () =>
        If(
          [[], input],
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.ExtendsMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown] | [], context), input],
  )
export const Base = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('(', input), ([_0, input]) => If(Type(input, context), ([_1, input]) => If(Runtime.Token.Const(')', input), ([_2, input]) => [[_0, _1, _2], input]))),
      ([_0, input]) => [_0, input],
      () =>
        If(
          Keyword(input, context),
          ([_0, input]) => [_0, input],
          () =>
            If(
              _Object(input, context),
              ([_0, input]) => [_0, input],
              () =>
                If(
                  Tuple(input, context),
                  ([_0, input]) => [_0, input],
                  () =>
                    If(
                      Literal(input, context),
                      ([_0, input]) => [_0, input],
                      () =>
                        If(
                          Constructor(input, context),
                          ([_0, input]) => [_0, input],
                          () =>
                            If(
                              Function(input, context),
                              ([_0, input]) => [_0, input],
                              () =>
                                If(
                                  Mapped(input, context),
                                  ([_0, input]) => [_0, input],
                                  () =>
                                    If(
                                      AsyncIterator(input, context),
                                      ([_0, input]) => [_0, input],
                                      () =>
                                        If(
                                          Iterator(input, context),
                                          ([_0, input]) => [_0, input],
                                          () =>
                                            If(
                                              ConstructorParameters(input, context),
                                              ([_0, input]) => [_0, input],
                                              () =>
                                                If(
                                                  FunctionParameters(input, context),
                                                  ([_0, input]) => [_0, input],
                                                  () =>
                                                    If(
                                                      InstanceType(input, context),
                                                      ([_0, input]) => [_0, input],
                                                      () =>
                                                        If(
                                                          ReturnType(input, context),
                                                          ([_0, input]) => [_0, input],
                                                          () =>
                                                            If(
                                                              Argument(input, context),
                                                              ([_0, input]) => [_0, input],
                                                              () =>
                                                                If(
                                                                  Awaited(input, context),
                                                                  ([_0, input]) => [_0, input],
                                                                  () =>
                                                                    If(
                                                                      Array(input, context),
                                                                      ([_0, input]) => [_0, input],
                                                                      () =>
                                                                        If(
                                                                          Record(input, context),
                                                                          ([_0, input]) => [_0, input],
                                                                          () =>
                                                                            If(
                                                                              Promise(input, context),
                                                                              ([_0, input]) => [_0, input],
                                                                              () =>
                                                                                If(
                                                                                  Partial(input, context),
                                                                                  ([_0, input]) => [_0, input],
                                                                                  () =>
                                                                                    If(
                                                                                      Required(input, context),
                                                                                      ([_0, input]) => [_0, input],
                                                                                      () =>
                                                                                        If(
                                                                                          Pick(input, context),
                                                                                          ([_0, input]) => [_0, input],
                                                                                          () =>
                                                                                            If(
                                                                                              Omit(input, context),
                                                                                              ([_0, input]) => [_0, input],
                                                                                              () =>
                                                                                                If(
                                                                                                  Exclude(input, context),
                                                                                                  ([_0, input]) => [_0, input],
                                                                                                  () =>
                                                                                                    If(
                                                                                                      Extract(input, context),
                                                                                                      ([_0, input]) => [_0, input],
                                                                                                      () =>
                                                                                                        If(
                                                                                                          Uppercase(input, context),
                                                                                                          ([_0, input]) => [_0, input],
                                                                                                          () =>
                                                                                                            If(
                                                                                                              Lowercase(input, context),
                                                                                                              ([_0, input]) => [_0, input],
                                                                                                              () =>
                                                                                                                If(
                                                                                                                  Capitalize(input, context),
                                                                                                                  ([_0, input]) => [_0, input],
                                                                                                                  () =>
                                                                                                                    If(
                                                                                                                      Uncapitalize(input, context),
                                                                                                                      ([_0, input]) => [_0, input],
                                                                                                                      () =>
                                                                                                                        If(
                                                                                                                          Date(input, context),
                                                                                                                          ([_0, input]) => [_0, input],
                                                                                                                          () =>
                                                                                                                            If(
                                                                                                                              Uint8Array(input, context),
                                                                                                                              ([_0, input]) => [_0, input],
                                                                                                                              () =>
                                                                                                                                If(
                                                                                                                                  GenericReference(input, context),
                                                                                                                                  ([_0, input]) => [_0, input],
                                                                                                                                  () =>
                                                                                                                                    If(
                                                                                                                                      Reference(input, context),
                                                                                                                                      ([_0, input]) => [_0, input],
                                                                                                                                      () => [],
                                                                                                                                    ),
                                                                                                                                ),
                                                                                                                            ),
                                                                                                                        ),
                                                                                                                    ),
                                                                                                                ),
                                                                                                            ),
                                                                                                        ),
                                                                                                    ),
                                                                                                ),
                                                                                            ),
                                                                                        ),
                                                                                    ),
                                                                                ),
                                                                            ),
                                                                        ),
                                                                    ),
                                                                ),
                                                            ),
                                                        ),
                                                    ),
                                                ),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                ),
            ),
        ),
    ),
    ([_0, input]) => [S.BaseMapping(_0 as [unknown, unknown, unknown] | unknown, context), input],
  )
export const Factor = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(KeyOf(input, context), ([_0, input]) => If(Base(input, context), ([_1, input]) => If(IndexArray(input, context), ([_2, input]) => If(Extends(input, context), ([_3, input]) => [[_0, _1, _2, _3], input])))),
    ([_0, input]) => [S.FactorMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const ExprTermTail = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('&', input), ([_0, input]) => If(Factor(input, context), ([_1, input]) => If(ExprTermTail(input, context), ([_2, input]) => [[_0, _1, _2], input]))),
      ([_0, input]) => [_0, input],
      () =>
        If(
          [[], input],
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.ExprTermTailMapping(_0 as [unknown, unknown, unknown] | [], context), input],
  )
export const ExprTerm = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Factor(input, context), ([_0, input]) => If(ExprTermTail(input, context), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => [S.ExprTermMapping(_0 as [unknown, unknown], context), input],
  )
export const ExprTail = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('|', input), ([_0, input]) => If(ExprTerm(input, context), ([_1, input]) => If(ExprTail(input, context), ([_2, input]) => [[_0, _1, _2], input]))),
      ([_0, input]) => [_0, input],
      () =>
        If(
          [[], input],
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.ExprTailMapping(_0 as [unknown, unknown, unknown] | [], context), input],
  )
export const Expr = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(ExprTerm(input, context), ([_0, input]) => If(ExprTail(input, context), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => [S.ExprMapping(_0 as [unknown, unknown], context), input],
  )
export const Type = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(
        GenericArguments(input, context),
        ([_0, input]) => Expr(input, _0 as T.TProperties),
        () => [],
      ),
      ([_0, input]) => [_0, input],
      () =>
        If(
          Expr(input, context),
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.TypeMapping(_0 as unknown, context), input],
  )
export const PropertyKey = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      Runtime.Token.Ident(input),
      ([_0, input]) => [_0, input],
      () =>
        If(
          Runtime.Token.String(["'", '"'], input),
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.PropertyKeyMapping(_0 as string, context), input],
  )
export const Readonly = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('readonly', input), ([_0, input]) => [[_0], input]),
      ([_0, input]) => [_0, input],
      () =>
        If(
          [[], input],
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.ReadonlyMapping(_0 as [unknown] | [], context), input],
  )
export const Optional = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const('?', input), ([_0, input]) => [[_0], input]),
      ([_0, input]) => [_0, input],
      () =>
        If(
          [[], input],
          ([_0, input]) => [_0, input],
          () => [],
        ),
    ),
    ([_0, input]) => [S.OptionalMapping(_0 as [unknown] | [], context), input],
  )
export const Property = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Readonly(input, context), ([_0, input]) =>
      If(PropertyKey(input, context), ([_1, input]) => If(Optional(input, context), ([_2, input]) => If(Runtime.Token.Const(':', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => [[_0, _1, _2, _3, _4], input])))),
    ),
    ([_0, input]) => [S.PropertyMapping(_0 as [unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const PropertyDelimiter = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(
      If(Runtime.Token.Const(',', input), ([_0, input]) => If(Runtime.Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])),
      ([_0, input]) => [_0, input],
      () =>
        If(
          If(Runtime.Token.Const(';', input), ([_0, input]) => If(Runtime.Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])),
          ([_0, input]) => [_0, input],
          () =>
            If(
              If(Runtime.Token.Const(',', input), ([_0, input]) => [[_0], input]),
              ([_0, input]) => [_0, input],
              () =>
                If(
                  If(Runtime.Token.Const(';', input), ([_0, input]) => [[_0], input]),
                  ([_0, input]) => [_0, input],
                  () =>
                    If(
                      If(Runtime.Token.Const('\n', input), ([_0, input]) => [[_0], input]),
                      ([_0, input]) => [_0, input],
                      () => [],
                    ),
                ),
            ),
        ),
    ),
    ([_0, input]) => [S.PropertyDelimiterMapping(_0 as [unknown, unknown] | [unknown], context), input],
  )
export const PropertyList_0 = (input: string, context: T.TProperties, result: unknown[] = []): [unknown[], string] =>
  If(
    If(Property(input, context), ([_0, input]) => If(PropertyDelimiter(input, context), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => PropertyList_0(input, context, [...result, _0]),
    () => [result, input],
  ) as [unknown[], string]
export const PropertyList = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(PropertyList_0(input, context), ([_0, input]) =>
      If(
        If(
          If(Property(input, context), ([_0, input]) => [[_0], input]),
          ([_0, input]) => [_0, input],
          () =>
            If(
              [[], input],
              ([_0, input]) => [_0, input],
              () => [],
            ),
        ),
        ([_1, input]) => [[_0, _1], input],
      ),
    ),
    ([_0, input]) => [S.PropertyListMapping(_0 as [unknown, unknown], context), input],
  )
export const _Object = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('{', input), ([_0, input]) => If(PropertyList(input, context), ([_1, input]) => If(Runtime.Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))),
    ([_0, input]) => [S.ObjectMapping(_0 as [unknown, unknown, unknown], context), input],
  )
export const ElementList_0 = (input: string, context: T.TProperties, result: unknown[] = []): [unknown[], string] =>
  If(
    If(Type(input, context), ([_0, input]) => If(Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => ElementList_0(input, context, [...result, _0]),
    () => [result, input],
  ) as [unknown[], string]
export const ElementList = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(ElementList_0(input, context), ([_0, input]) =>
      If(
        If(
          If(Type(input, context), ([_0, input]) => [[_0], input]),
          ([_0, input]) => [_0, input],
          () =>
            If(
              [[], input],
              ([_0, input]) => [_0, input],
              () => [],
            ),
        ),
        ([_1, input]) => [[_0, _1], input],
      ),
    ),
    ([_0, input]) => [S.ElementListMapping(_0 as [unknown, unknown], context), input],
  )
export const Tuple = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('[', input), ([_0, input]) => If(ElementList(input, context), ([_1, input]) => If(Runtime.Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))),
    ([_0, input]) => [S.TupleMapping(_0 as [unknown, unknown, unknown], context), input],
  )
export const Parameter = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Ident(input), ([_0, input]) => If(Runtime.Token.Const(':', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => [[_0, _1, _2], input]))),
    ([_0, input]) => [S.ParameterMapping(_0 as [unknown, unknown, unknown], context), input],
  )
export const ParameterList_0 = (input: string, context: T.TProperties, result: unknown[] = []): [unknown[], string] =>
  If(
    If(Parameter(input, context), ([_0, input]) => If(Runtime.Token.Const(',', input), ([_1, input]) => [[_0, _1], input])),
    ([_0, input]) => ParameterList_0(input, context, [...result, _0]),
    () => [result, input],
  ) as [unknown[], string]
export const ParameterList = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(ParameterList_0(input, context), ([_0, input]) =>
      If(
        If(
          If(Parameter(input, context), ([_0, input]) => [[_0], input]),
          ([_0, input]) => [_0, input],
          () =>
            If(
              [[], input],
              ([_0, input]) => [_0, input],
              () => [],
            ),
        ),
        ([_1, input]) => [[_0, _1], input],
      ),
    ),
    ([_0, input]) => [S.ParameterListMapping(_0 as [unknown, unknown], context), input],
  )
export const Function = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('(', input), ([_0, input]) =>
      If(ParameterList(input, context), ([_1, input]) => If(Runtime.Token.Const(')', input), ([_2, input]) => If(Runtime.Token.Const('=>', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => [[_0, _1, _2, _3, _4], input])))),
    ),
    ([_0, input]) => [S.FunctionMapping(_0 as [unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Constructor = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('new', input), ([_0, input]) =>
      If(Runtime.Token.Const('(', input), ([_1, input]) =>
        If(ParameterList(input, context), ([_2, input]) =>
          If(Runtime.Token.Const(')', input), ([_3, input]) => If(Runtime.Token.Const('=>', input), ([_4, input]) => If(Type(input, context), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input]))),
        ),
      ),
    ),
    ([_0, input]) => [S.ConstructorMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Mapped = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('{', input), ([_0, input]) =>
      If(Runtime.Token.Const('[', input), ([_1, input]) =>
        If(Runtime.Token.Ident(input), ([_2, input]) =>
          If(Runtime.Token.Const('in', input), ([_3, input]) =>
            If(Type(input, context), ([_4, input]) =>
              If(Runtime.Token.Const(']', input), ([_5, input]) =>
                If(Runtime.Token.Const(':', input), ([_6, input]) => If(Type(input, context), ([_7, input]) => If(Runtime.Token.Const('}', input), ([_8, input]) => [[_0, _1, _2, _3, _4, _5, _6, _7, _8], input]))),
              ),
            ),
          ),
        ),
      ),
    ),
    ([_0, input]) => [S.MappedMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const AsyncIterator = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('AsyncIterator', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.AsyncIteratorMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Iterator = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Iterator', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.IteratorMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Argument = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Argument', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.ArgumentMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Awaited = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Awaited', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.AwaitedMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Array = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Array', input), ([_0, input]) => If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input])))),
    ([_0, input]) => [S.ArrayMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Record = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Record', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) =>
        If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const(',', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => If(Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))),
      ),
    ),
    ([_0, input]) => [S.RecordMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Promise = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Promise', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.PromiseMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const ConstructorParameters = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('ConstructorParameters', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.ConstructorParametersMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const FunctionParameters = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Parameters', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.FunctionParametersMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const InstanceType = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('InstanceType', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.InstanceTypeMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const ReturnType = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('ReturnType', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.ReturnTypeMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Partial = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Partial', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.PartialMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Required = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Required', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.RequiredMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Pick = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Pick', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) =>
        If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const(',', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => If(Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))),
      ),
    ),
    ([_0, input]) => [S.PickMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Omit = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Omit', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) =>
        If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const(',', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => If(Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))),
      ),
    ),
    ([_0, input]) => [S.OmitMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Exclude = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Exclude', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) =>
        If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const(',', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => If(Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))),
      ),
    ),
    ([_0, input]) => [S.ExcludeMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Extract = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Extract', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) =>
        If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const(',', input), ([_3, input]) => If(Type(input, context), ([_4, input]) => If(Runtime.Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))),
      ),
    ),
    ([_0, input]) => [S.ExtractMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown], context), input],
  )
export const Uppercase = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Uppercase', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.UppercaseMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Lowercase = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Lowercase', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.LowercaseMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Capitalize = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Capitalize', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.CapitalizeMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Uncapitalize = (input: string, context: T.TProperties = {}): [unknown, string] | [] =>
  If(
    If(Runtime.Token.Const('Uncapitalize', input), ([_0, input]) =>
      If(Runtime.Token.Const('<', input), ([_1, input]) => If(Type(input, context), ([_2, input]) => If(Runtime.Token.Const('>', input), ([_3, input]) => [[_0, _1, _2, _3], input]))),
    ),
    ([_0, input]) => [S.UncapitalizeMapping(_0 as [unknown, unknown, unknown, unknown], context), input],
  )
export const Date = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('Date', input), ([_0, input]) => [S.DateMapping(_0 as 'Date', context), input])
export const Uint8Array = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Const('Uint8Array', input), ([_0, input]) => [S.Uint8ArrayMapping(_0 as 'Uint8Array', context), input])
export const Reference = (input: string, context: T.TProperties = {}): [unknown, string] | [] => If(Runtime.Token.Ident(input), ([_0, input]) => [S.ReferenceMapping(_0 as string, context), input])
