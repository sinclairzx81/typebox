/*--------------------------------------------------------------------------

TypeBox

The MIT License (MIT)

Copyright (c) 2017-2025 Haydn Paterson 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

---------------------------------------------------------------------------*/

// deno-fmt-ignore-file
// deno-lint-ignore-file

import * as S from './mapping.ts'
import * as Token from './token/index.ts'

export type TGenericParameterExtendsEquals<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'extends', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? (Token.TConst<'=', Input> extends [infer _3, infer Input extends string] ? (TType<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TGenericParameterExtendsEqualsMapping<_0>, Input] : []
export type TGenericParameterExtends<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'extends', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TGenericParameterExtendsMapping<_0>, Input] : []
export type TGenericParameterEquals<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'=', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TGenericParameterEqualsMapping<_0>, Input] : []
export type TGenericParameterIdentifier<Input extends string> = Token.TIdent<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TGenericParameterIdentifierMapping<_0>, Input] : []
export type TGenericParameter<Input extends string> = (TGenericParameterExtendsEquals<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TGenericParameterExtends<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TGenericParameterEquals<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TGenericParameterIdentifier<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TGenericParameterMapping<_0>, Input] : []
export type TGenericParameterList_0<Input extends string, Result extends unknown[] = []> = (TGenericParameter<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TGenericParameterList_0<Input, [...Result, _0]> : [Result, Input]
export type TGenericParameterList<Input extends string> = (TGenericParameterList_0<Input> extends [infer _0, infer Input extends string] ? (((TGenericParameter<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TGenericParameterListMapping<_0>, Input] : []
export type TGenericParameters<Input extends string> = (Token.TConst<'<', Input> extends [infer _0, infer Input extends string] ? (TGenericParameterList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'>', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TGenericParametersMapping<_0>, Input] : []
export type TGenericCallArgumentList_0<Input extends string, Result extends unknown[] = []> = (TType<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TGenericCallArgumentList_0<Input, [...Result, _0]> : [Result, Input]
export type TGenericCallArgumentList<Input extends string> = (TGenericCallArgumentList_0<Input> extends [infer _0, infer Input extends string] ? (((TType<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TGenericCallArgumentListMapping<_0>, Input] : []
export type TGenericCallArguments<Input extends string> = (Token.TConst<'<', Input> extends [infer _0, infer Input extends string] ? (TGenericCallArgumentList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'>', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TGenericCallArgumentsMapping<_0>, Input] : []
export type TGenericCall<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (TGenericCallArguments<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TGenericCallMapping<_0>, Input] : []
export type TKeywordString<Input extends string> = Token.TConst<'string', Input> extends [infer _0 extends 'string', infer Input extends string] ? [S.TKeywordStringMapping<_0>, Input] : []
export type TKeywordNumber<Input extends string> = Token.TConst<'number', Input> extends [infer _0 extends 'number', infer Input extends string] ? [S.TKeywordNumberMapping<_0>, Input] : []
export type TKeywordBoolean<Input extends string> = Token.TConst<'boolean', Input> extends [infer _0 extends 'boolean', infer Input extends string] ? [S.TKeywordBooleanMapping<_0>, Input] : []
export type TKeywordUndefined<Input extends string> = Token.TConst<'undefined', Input> extends [infer _0 extends 'undefined', infer Input extends string] ? [S.TKeywordUndefinedMapping<_0>, Input] : []
export type TKeywordNull<Input extends string> = Token.TConst<'null', Input> extends [infer _0 extends 'null', infer Input extends string] ? [S.TKeywordNullMapping<_0>, Input] : []
export type TKeywordInteger<Input extends string> = Token.TConst<'integer', Input> extends [infer _0 extends 'integer', infer Input extends string] ? [S.TKeywordIntegerMapping<_0>, Input] : []
export type TKeywordBigInt<Input extends string> = Token.TConst<'bigint', Input> extends [infer _0 extends 'bigint', infer Input extends string] ? [S.TKeywordBigIntMapping<_0>, Input] : []
export type TKeywordUnknown<Input extends string> = Token.TConst<'unknown', Input> extends [infer _0 extends 'unknown', infer Input extends string] ? [S.TKeywordUnknownMapping<_0>, Input] : []
export type TKeywordAny<Input extends string> = Token.TConst<'any', Input> extends [infer _0 extends 'any', infer Input extends string] ? [S.TKeywordAnyMapping<_0>, Input] : []
export type TKeywordObject<Input extends string> = Token.TConst<'object', Input> extends [infer _0 extends 'object', infer Input extends string] ? [S.TKeywordObjectMapping<_0>, Input] : []
export type TKeywordNever<Input extends string> = Token.TConst<'never', Input> extends [infer _0 extends 'never', infer Input extends string] ? [S.TKeywordNeverMapping<_0>, Input] : []
export type TKeywordSymbol<Input extends string> = Token.TConst<'symbol', Input> extends [infer _0 extends 'symbol', infer Input extends string] ? [S.TKeywordSymbolMapping<_0>, Input] : []
export type TKeywordVoid<Input extends string> = Token.TConst<'void', Input> extends [infer _0 extends 'void', infer Input extends string] ? [S.TKeywordVoidMapping<_0>, Input] : []
export type TKeywordThis<Input extends string> = Token.TConst<'this', Input> extends [infer _0 extends 'this', infer Input extends string] ? [S.TKeywordThisMapping<_0>, Input] : []
export type TKeyword<Input extends string> = (TKeywordString<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNumber<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordBoolean<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordUndefined<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNull<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordInteger<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordBigInt<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordUnknown<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordAny<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordObject<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNever<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordSymbol<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordVoid<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordThis<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TKeywordMapping<_0>, Input] : []
export type TTemplateInterpolate<Input extends string> = (Token.TConst<'${', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'}', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TTemplateInterpolateMapping<_0>, Input] : []
export type TTemplateSpan<Input extends string> = Token.TUntil<['${', '`'], Input> extends [infer _0 extends string, infer Input extends string] ? [S.TTemplateSpanMapping<_0>, Input] : []
export type TTemplateBody<Input extends string> = ((TTemplateSpan<Input> extends [infer _0, infer Input extends string] ? (TTemplateInterpolate<Input> extends [infer _1, infer Input extends string] ? (TTemplateBody<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (TTemplateSpan<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (TTemplateSpan<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | [unknown], infer Input extends string] ? [S.TTemplateBodyMapping<_0>, Input] : []
export type TTemplateLiteralTypes<Input extends string> = (Token.TConst<'`', Input> extends [infer _0, infer Input extends string] ? (TTemplateBody<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'`', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TTemplateLiteralTypesMapping<_0>, Input] : []
export type TTemplateLiteral<Input extends string> = TTemplateLiteralTypes<Input> extends [infer _0 extends unknown, infer Input extends string] ? [S.TTemplateLiteralMapping<_0>, Input] : []
export type TLiteralBigInt<Input extends string> = Token.TBigInt<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TLiteralBigIntMapping<_0>, Input] : []
export type TLiteralBoolean<Input extends string> = (Token.TConst<'true', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : Token.TConst<'false', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends 'true' | 'false', infer Input extends string] ? [S.TLiteralBooleanMapping<_0>, Input] : []
export type TLiteralNumber<Input extends string> = Token.TNumber<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TLiteralNumberMapping<_0>, Input] : []
export type TLiteralString<Input extends string> = Token.TString<['\'', '\"'], Input> extends [infer _0 extends string, infer Input extends string] ? [S.TLiteralStringMapping<_0>, Input] : []
export type TLiteral<Input extends string> = (TLiteralBigInt<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteralBoolean<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteralNumber<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteralString<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TLiteralMapping<_0>, Input] : []
export type TKeyOf<Input extends string> = ((Token.TConst<'keyof', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TKeyOfMapping<_0>, Input] : []
export type TIndexArray_0<Input extends string, Result extends unknown[] = []> = ((Token.TConst<'[', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<']', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'[', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<']', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0, infer Input extends string] ? TIndexArray_0<Input, [...Result, _0]> : [Result, Input]
export type TIndexArray<Input extends string> = TIndexArray_0<Input> extends [infer _0 extends ([unknown, unknown, unknown] | [unknown, unknown])[], infer Input extends string] ? [S.TIndexArrayMapping<_0>, Input] : []
export type TExtends<Input extends string> = ((Token.TConst<'extends', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _2, infer Input extends string] ? (TType<Input> extends [infer _3, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _4, infer Input extends string] ? (TType<Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : []) : []) : []) : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown] | [], infer Input extends string] ? [S.TExtendsMapping<_0>, Input] : []
export type TBase<Input extends string> = ((Token.TConst<'(', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<')', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : TKeyword<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TObject<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TTuple<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TTemplateLiteral<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TLiteral<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TConstructor<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TFunction<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TMapped<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TOptions<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TGenericCall<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TReference<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | unknown, infer Input extends string] ? [S.TBaseMapping<_0>, Input] : []
export type TFactor<Input extends string> = (TKeyOf<Input> extends [infer _0, infer Input extends string] ? (TBase<Input> extends [infer _1, infer Input extends string] ? (TIndexArray<Input> extends [infer _2, infer Input extends string] ? (TExtends<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TFactorMapping<_0>, Input] : []
export type TExprTermTail<Input extends string> = ((Token.TConst<'&', Input> extends [infer _0, infer Input extends string] ? (TFactor<Input> extends [infer _1, infer Input extends string] ? (TExprTermTail<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | [], infer Input extends string] ? [S.TExprTermTailMapping<_0>, Input] : []
export type TExprTerm<Input extends string> = (TFactor<Input> extends [infer _0, infer Input extends string] ? (TExprTermTail<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TExprTermMapping<_0>, Input] : []
export type TExprTail<Input extends string> = ((Token.TConst<'|', Input> extends [infer _0, infer Input extends string] ? (TExprTerm<Input> extends [infer _1, infer Input extends string] ? (TExprTail<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | [], infer Input extends string] ? [S.TExprTailMapping<_0>, Input] : []
export type TExpr<Input extends string> = (TExprTerm<Input> extends [infer _0, infer Input extends string] ? (TExprTail<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TExprMapping<_0>, Input] : []
export type TExprPipe<Input extends string> = (Token.TConst<'|', Input> extends [infer _0, infer Input extends string] ? (TExpr<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TExprPipeMapping<_0>, Input] : []
export type TGenericType<Input extends string> = (TGenericParameters<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'=', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TGenericTypeMapping<_0>, Input] : []
export type TInferType<Input extends string> = ((Token.TConst<'infer', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'extends', Input> extends [infer _2, infer Input extends string] ? (TExpr<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'infer', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown] | [unknown, unknown], infer Input extends string] ? [S.TInferTypeMapping<_0>, Input] : []
export type TType<Input extends string> = (TInferType<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TExprPipe<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TExpr<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TTypeMapping<_0>, Input] : []
export type TPropertyKeyNumber<Input extends string> = Token.TNumber<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TPropertyKeyNumberMapping<_0>, Input] : []
export type TPropertyKeyIdent<Input extends string> = Token.TIdent<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TPropertyKeyIdentMapping<_0>, Input] : []
export type TPropertyKeyQuoted<Input extends string> = Token.TString<['\'', '\"'], Input> extends [infer _0 extends string, infer Input extends string] ? [S.TPropertyKeyQuotedMapping<_0>, Input] : []
export type TPropertyKeyIndex<Input extends string> = (Token.TConst<'[', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _2, infer Input extends string] ? ((TKeywordInteger<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordNumber<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordString<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TKeywordSymbol<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _3, infer Input extends string] ? (Token.TConst<']', Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TPropertyKeyIndexMapping<_0>, Input] : []
export type TPropertyKey<Input extends string> = (TPropertyKeyNumber<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPropertyKeyIdent<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPropertyKeyQuoted<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPropertyKeyIndex<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TPropertyKeyMapping<_0>, Input] : []
export type TReadonly<Input extends string> = ((Token.TConst<'readonly', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TReadonlyMapping<_0>, Input] : []
export type TOptional<Input extends string> = ((Token.TConst<'?', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TOptionalMapping<_0>, Input] : []
export type TProperty<Input extends string> = (TReadonly<Input> extends [infer _0, infer Input extends string] ? (TPropertyKey<Input> extends [infer _1, infer Input extends string] ? (TOptional<Input> extends [infer _2, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _3, infer Input extends string] ? (TType<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TPropertyMapping<_0>, Input] : []
export type TPropertyDelimiter<Input extends string> = ((Token.TConst<',', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<';', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<',', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<';', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'\n', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown], infer Input extends string] ? [S.TPropertyDelimiterMapping<_0>, Input] : []
export type TPropertyList_0<Input extends string, Result extends unknown[] = []> = (TProperty<Input> extends [infer _0, infer Input extends string] ? (TPropertyDelimiter<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TPropertyList_0<Input, [...Result, _0]> : [Result, Input]
export type TPropertyList<Input extends string> = (TPropertyList_0<Input> extends [infer _0, infer Input extends string] ? (((TProperty<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TPropertyListMapping<_0>, Input] : []
export type TProperties<Input extends string> = (Token.TConst<'{', Input> extends [infer _0, infer Input extends string] ? (TPropertyList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'}', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TPropertiesMapping<_0>, Input] : []
export type TObject<Input extends string> = TProperties<Input> extends [infer _0 extends unknown, infer Input extends string] ? [S.TObjectMapping<_0>, Input] : []
export type TElementNamed<Input extends string> = ((Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _2, infer Input extends string] ? (Token.TConst<'readonly', Input> extends [infer _3, infer Input extends string] ? (TType<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'readonly', Input> extends [infer _2, infer Input extends string] ? (TType<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _2, infer Input extends string] ? (TType<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown] | [unknown, unknown, unknown, unknown] | [unknown, unknown, unknown], infer Input extends string] ? [S.TElementNamedMapping<_0>, Input] : []
export type TElementReadonlyOptional<Input extends string> = (Token.TConst<'readonly', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TElementReadonlyOptionalMapping<_0>, Input] : []
export type TElementReadonly<Input extends string> = (Token.TConst<'readonly', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TElementReadonlyMapping<_0>, Input] : []
export type TElementOptional<Input extends string> = (TType<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TElementOptionalMapping<_0>, Input] : []
export type TElementBase<Input extends string> = (TElementNamed<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TElementReadonlyOptional<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TElementReadonly<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TElementOptional<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TType<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TElementBaseMapping<_0>, Input] : []
export type TElement<Input extends string> = ((Token.TConst<'...', Input> extends [infer _0, infer Input extends string] ? (TElementBase<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (TElementBase<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown], infer Input extends string] ? [S.TElementMapping<_0>, Input] : []
export type TElementList_0<Input extends string, Result extends unknown[] = []> = (TElement<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TElementList_0<Input, [...Result, _0]> : [Result, Input]
export type TElementList<Input extends string> = (TElementList_0<Input> extends [infer _0, infer Input extends string] ? (((TElement<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TElementListMapping<_0>, Input] : []
export type TTuple<Input extends string> = (Token.TConst<'[', Input> extends [infer _0, infer Input extends string] ? (TElementList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<']', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TTupleMapping<_0>, Input] : []
export type TParameterReadonlyOptional<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _2, infer Input extends string] ? (Token.TConst<'readonly', Input> extends [infer _3, infer Input extends string] ? (TType<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TParameterReadonlyOptionalMapping<_0>, Input] : []
export type TParameterReadonly<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'readonly', Input> extends [infer _2, infer Input extends string] ? (TType<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TParameterReadonlyMapping<_0>, Input] : []
export type TParameterOptional<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _2, infer Input extends string] ? (TType<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TParameterOptionalMapping<_0>, Input] : []
export type TParameterType<Input extends string> = (Token.TIdent<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TParameterTypeMapping<_0>, Input] : []
export type TParameterBase<Input extends string> = (TParameterReadonlyOptional<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TParameterReadonly<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TParameterOptional<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TParameterType<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TParameterBaseMapping<_0>, Input] : []
export type TParameter<Input extends string> = ((Token.TConst<'...', Input> extends [infer _0, infer Input extends string] ? (TParameterBase<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (TParameterBase<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown], infer Input extends string] ? [S.TParameterMapping<_0>, Input] : []
export type TParameterList_0<Input extends string, Result extends unknown[] = []> = (TParameter<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TParameterList_0<Input, [...Result, _0]> : [Result, Input]
export type TParameterList<Input extends string> = (TParameterList_0<Input> extends [infer _0, infer Input extends string] ? (((TParameter<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TParameterListMapping<_0>, Input] : []
export type TFunction<Input extends string> = (Token.TConst<'(', Input> extends [infer _0, infer Input extends string] ? (TParameterList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<')', Input> extends [infer _2, infer Input extends string] ? (Token.TConst<'=>', Input> extends [infer _3, infer Input extends string] ? (TType<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TFunctionMapping<_0>, Input] : []
export type TConstructor<Input extends string> = (Token.TConst<'new', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'(', Input> extends [infer _1, infer Input extends string] ? (TParameterList<Input> extends [infer _2, infer Input extends string] ? (Token.TConst<')', Input> extends [infer _3, infer Input extends string] ? (Token.TConst<'=>', Input> extends [infer _4, infer Input extends string] ? (TType<Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : []) : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TConstructorMapping<_0>, Input] : []
export type TMappedReadonly<Input extends string> = ((Token.TConst<'+', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'readonly', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'-', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'readonly', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'readonly', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown] | [], infer Input extends string] ? [S.TMappedReadonlyMapping<_0>, Input] : []
export type TMappedOptional<Input extends string> = ((Token.TConst<'+', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'-', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'?', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'?', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown] | [], infer Input extends string] ? [S.TMappedOptionalMapping<_0>, Input] : []
export type TMappedAs<Input extends string> = ((Token.TConst<'as', Input> extends [infer _0, infer Input extends string] ? (TType<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [], infer Input extends string] ? [S.TMappedAsMapping<_0>, Input] : []
export type TMapped<Input extends string> = (Token.TConst<'{', Input> extends [infer _0, infer Input extends string] ? (TMappedReadonly<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'[', Input> extends [infer _2, infer Input extends string] ? (Token.TIdent<Input> extends [infer _3, infer Input extends string] ? (Token.TConst<'in', Input> extends [infer _4, infer Input extends string] ? (TType<Input> extends [infer _5, infer Input extends string] ? (TMappedAs<Input> extends [infer _6, infer Input extends string] ? (Token.TConst<']', Input> extends [infer _7, infer Input extends string] ? (TMappedOptional<Input> extends [infer _8, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _9, infer Input extends string] ? (TType<Input> extends [infer _10, infer Input extends string] ? (Token.TConst<'}', Input> extends [infer _11, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11], Input] : []) : []) : []) : []) : []) : []) : []) : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TMappedMapping<_0>, Input] : []
export type TReference<Input extends string> = Token.TIdent<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TReferenceMapping<_0>, Input] : []
export type TOptions<Input extends string> = (Token.TConst<'Options', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'<', Input> extends [infer _1, infer Input extends string] ? (TType<Input> extends [infer _2, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _3, infer Input extends string] ? (TJsonObject<Input> extends [infer _4, infer Input extends string] ? (Token.TConst<'>', Input> extends [infer _5, infer Input extends string] ? [[_0, _1, _2, _3, _4, _5], Input] : []) : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TOptionsMapping<_0>, Input] : []
export type TJsonNumber<Input extends string> = Token.TNumber<Input> extends [infer _0 extends string, infer Input extends string] ? [S.TJsonNumberMapping<_0>, Input] : []
export type TJsonBoolean<Input extends string> = (Token.TConst<'true', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : Token.TConst<'false', Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends 'true' | 'false', infer Input extends string] ? [S.TJsonBooleanMapping<_0>, Input] : []
export type TJsonString<Input extends string> = Token.TString<['\"', '\''], Input> extends [infer _0 extends string, infer Input extends string] ? [S.TJsonStringMapping<_0>, Input] : []
export type TJsonNull<Input extends string> = Token.TConst<'null', Input> extends [infer _0 extends 'null', infer Input extends string] ? [S.TJsonNullMapping<_0>, Input] : []
export type TJsonProperty<Input extends string> = (TPropertyKey<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<':', Input> extends [infer _1, infer Input extends string] ? (TJson<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TJsonPropertyMapping<_0>, Input] : []
export type TJsonPropertyList_0<Input extends string, Result extends unknown[] = []> = (TJsonProperty<Input> extends [infer _0, infer Input extends string] ? (TPropertyDelimiter<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TJsonPropertyList_0<Input, [...Result, _0]> : [Result, Input]
export type TJsonPropertyList<Input extends string> = (TJsonPropertyList_0<Input> extends [infer _0, infer Input extends string] ? (((TJsonProperty<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TJsonPropertyListMapping<_0>, Input] : []
export type TJsonObject<Input extends string> = (Token.TConst<'{', Input> extends [infer _0, infer Input extends string] ? (TJsonPropertyList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'}', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TJsonObjectMapping<_0>, Input] : []
export type TJsonElementList_0<Input extends string, Result extends unknown[] = []> = (TJson<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TJsonElementList_0<Input, [...Result, _0]> : [Result, Input]
export type TJsonElementList<Input extends string> = (TJsonElementList_0<Input> extends [infer _0, infer Input extends string] ? (((TJson<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TJsonElementListMapping<_0>, Input] : []
export type TJsonArray<Input extends string> = (Token.TConst<'[', Input> extends [infer _0, infer Input extends string] ? (TJsonElementList<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<']', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TJsonArrayMapping<_0>, Input] : []
export type TJson<Input extends string> = (TJsonNumber<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TJsonBoolean<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TJsonString<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TJsonNull<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TJsonObject<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TJsonArray<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TJsonMapping<_0>, Input] : []
export type TPatternBigInt<Input extends string> = Token.TConst<'-?(?:0|[1-9][0-9]*)n', Input> extends [infer _0 extends '-?(?:0|[1-9][0-9]*)n', infer Input extends string] ? [S.TPatternBigIntMapping<_0>, Input] : []
export type TPatternString<Input extends string> = Token.TConst<'.*', Input> extends [infer _0 extends '.*', infer Input extends string] ? [S.TPatternStringMapping<_0>, Input] : []
export type TPatternNumber<Input extends string> = Token.TConst<'-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', Input> extends [infer _0 extends '-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', infer Input extends string] ? [S.TPatternNumberMapping<_0>, Input] : []
export type TPatternInteger<Input extends string> = Token.TConst<'-?(?:0|[1-9][0-9]*)', Input> extends [infer _0 extends '-?(?:0|[1-9][0-9]*)', infer Input extends string] ? [S.TPatternIntegerMapping<_0>, Input] : []
export type TPatternNever<Input extends string> = Token.TConst<'(?!)', Input> extends [infer _0 extends '(?!)', infer Input extends string] ? [S.TPatternNeverMapping<_0>, Input] : []
export type TPatternText<Input extends string> = Token.TUntil_1<['-?(?:0|[1-9][0-9]*)n', '.*', '-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', '-?(?:0|[1-9][0-9]*)', '(?!)', '(', ')', '$', '|'], Input> extends [infer _0 extends string, infer Input extends string] ? [S.TPatternTextMapping<_0>, Input] : []
export type TPatternBase<Input extends string> = (TPatternBigInt<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternString<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternNumber<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternInteger<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternNever<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternGroup<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternText<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TPatternBaseMapping<_0>, Input] : []
export type TPatternGroup<Input extends string> = (Token.TConst<'(', Input> extends [infer _0, infer Input extends string] ? (TPatternBody<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<')', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TPatternGroupMapping<_0>, Input] : []
export type TPatternUnion<Input extends string> = ((TPatternTerm<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'|', Input> extends [infer _1, infer Input extends string] ? (TPatternUnion<Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (TPatternTerm<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown, unknown] | [unknown] | [], infer Input extends string] ? [S.TPatternUnionMapping<_0>, Input] : []
export type TPatternTerm<Input extends string> = (TPatternBase<Input> extends [infer _0, infer Input extends string] ? (TPatternBody<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TPatternTermMapping<_0>, Input] : []
export type TPatternBody<Input extends string> = (TPatternUnion<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TPatternTerm<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TPatternBodyMapping<_0>, Input] : []
export type TPattern<Input extends string> = (Token.TConst<'^', Input> extends [infer _0, infer Input extends string] ? (TPatternBody<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'$', Input> extends [infer _2, infer Input extends string] ? [[_0, _1, _2], Input] : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown], infer Input extends string] ? [S.TPatternMapping<_0>, Input] : []
export type TInterfaceDeclarationHeritageList_0<Input extends string, Result extends unknown[] = []> = (TType<Input> extends [infer _0, infer Input extends string] ? (Token.TConst<',', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TInterfaceDeclarationHeritageList_0<Input, [...Result, _0]> : [Result, Input]
export type TInterfaceDeclarationHeritageList<Input extends string> = (TInterfaceDeclarationHeritageList_0<Input> extends [infer _0, infer Input extends string] ? (((TType<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TInterfaceDeclarationHeritageListMapping<_0>, Input] : []
export type TInterfaceDeclarationHeritage<Input extends string> = ((Token.TConst<'extends', Input> extends [infer _0, infer Input extends string] ? (TInterfaceDeclarationHeritageList<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [], infer Input extends string] ? [S.TInterfaceDeclarationHeritageMapping<_0>, Input] : []
export type TInterfaceDeclarationGeneric<Input extends string> = (Token.TConst<'interface', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? (TGenericParameters<Input> extends [infer _2, infer Input extends string] ? (TInterfaceDeclarationHeritage<Input> extends [infer _3, infer Input extends string] ? (TProperties<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TInterfaceDeclarationGenericMapping<_0>, Input] : []
export type TInterfaceDeclaration<Input extends string> = (Token.TConst<'interface', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? (TInterfaceDeclarationHeritage<Input> extends [infer _2, infer Input extends string] ? (TProperties<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TInterfaceDeclarationMapping<_0>, Input] : []
export type TTypeAliasDeclarationGeneric<Input extends string> = (Token.TConst<'type', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? (TGenericParameters<Input> extends [infer _2, infer Input extends string] ? (Token.TConst<'=', Input> extends [infer _3, infer Input extends string] ? (TType<Input> extends [infer _4, infer Input extends string] ? [[_0, _1, _2, _3, _4], Input] : []) : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TTypeAliasDeclarationGenericMapping<_0>, Input] : []
export type TTypeAliasDeclaration<Input extends string> = (Token.TConst<'type', Input> extends [infer _0, infer Input extends string] ? (Token.TIdent<Input> extends [infer _1, infer Input extends string] ? (Token.TConst<'=', Input> extends [infer _2, infer Input extends string] ? (TType<Input> extends [infer _3, infer Input extends string] ? [[_0, _1, _2, _3], Input] : []) : []) : []) : []) extends [infer _0 extends [unknown, unknown, unknown, unknown], infer Input extends string] ? [S.TTypeAliasDeclarationMapping<_0>, Input] : []
export type TExportKeyword<Input extends string> = ((Token.TConst<'export', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown] | [], infer Input extends string] ? [S.TExportKeywordMapping<_0>, Input] : []
export type TModuleDeclarationDelimiter<Input extends string> = ((Token.TConst<';', Input> extends [infer _0, infer Input extends string] ? (Token.TConst<'\n', Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<';', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : (Token.TConst<'\n', Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends [unknown, unknown] | [unknown], infer Input extends string] ? [S.TModuleDeclarationDelimiterMapping<_0>, Input] : []
export type TModuleDeclarationList_0<Input extends string, Result extends unknown[] = []> = (TModuleDeclaration<Input> extends [infer _0, infer Input extends string] ? (TModuleDeclarationDelimiter<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0, infer Input extends string] ? TModuleDeclarationList_0<Input, [...Result, _0]> : [Result, Input]
export type TModuleDeclarationList<Input extends string> = (TModuleDeclarationList_0<Input> extends [infer _0, infer Input extends string] ? (((TModuleDeclaration<Input> extends [infer _0, infer Input extends string] ? [[_0], Input] : []) extends [infer _0, infer Input extends string] ? [_0, Input] : [[], Input] extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TModuleDeclarationListMapping<_0>, Input] : []
export type TModuleDeclaration<Input extends string> = (TExportKeyword<Input> extends [infer _0, infer Input extends string] ? ((TInterfaceDeclarationGeneric<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TInterfaceDeclaration<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TTypeAliasDeclarationGeneric<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TTypeAliasDeclaration<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TModuleDeclarationMapping<_0>, Input] : []
export type TModule<Input extends string> = (TModuleDeclaration<Input> extends [infer _0, infer Input extends string] ? (TModuleDeclarationList<Input> extends [infer _1, infer Input extends string] ? [[_0, _1], Input] : []) : []) extends [infer _0 extends [unknown, unknown], infer Input extends string] ? [S.TModuleMapping<_0>, Input] : []
export type TScript<Input extends string> = (TModule<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TGenericType<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : TType<Input> extends [infer _0, infer Input extends string] ? [_0, Input] : []) extends [infer _0 extends unknown, infer Input extends string] ? [S.TScriptMapping<_0>, Input] : []
const If = (result: [unknown, string] | [], left: (input: [unknown, string]) => [unknown, string] | [], right: () => [unknown, string] | [] = () => []): [unknown, string] | [] => result.length === 2 ? left(result) : right()

export const GenericParameterExtendsEquals = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('extends', input), ([_1, input]) => If(Type(input), ([_2, input]) => If(Token.Const('=', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.GenericParameterExtendsEqualsMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const GenericParameterExtends = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('extends', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericParameterExtendsMapping(_0 as [unknown, unknown, unknown]), input])
export const GenericParameterEquals = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('=', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericParameterEqualsMapping(_0 as [unknown, unknown, unknown]), input])
export const GenericParameterIdentifier = (input: string): [unknown, string] | [] => If(Token.Ident(input), ([_0, input]) => [S.GenericParameterIdentifierMapping(_0 as string), input])
export const GenericParameter = (input: string): [unknown, string] | [] => If(If(GenericParameterExtendsEquals(input), ([_0, input]) => [_0, input], () => If(GenericParameterExtends(input), ([_0, input]) => [_0, input], () => If(GenericParameterEquals(input), ([_0, input]) => [_0, input], () => If(GenericParameterIdentifier(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.GenericParameterMapping(_0 as unknown), input])
export const GenericParameterList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(GenericParameter(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => GenericParameterList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const GenericParameterList = (input: string): [unknown, string] | [] => If(If(GenericParameterList_0(input), ([_0, input]) => If(If(If(GenericParameter(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericParameterListMapping(_0 as [unknown, unknown]), input])
export const GenericParameters = (input: string): [unknown, string] | [] => If(If(Token.Const('<', input), ([_0, input]) => If(GenericParameterList(input), ([_1, input]) => If(Token.Const('>', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericParametersMapping(_0 as [unknown, unknown, unknown]), input])
export const GenericCallArgumentList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(Type(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => GenericCallArgumentList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const GenericCallArgumentList = (input: string): [unknown, string] | [] => If(If(GenericCallArgumentList_0(input), ([_0, input]) => If(If(If(Type(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericCallArgumentListMapping(_0 as [unknown, unknown]), input])
export const GenericCallArguments = (input: string): [unknown, string] | [] => If(If(Token.Const('<', input), ([_0, input]) => If(GenericCallArgumentList(input), ([_1, input]) => If(Token.Const('>', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericCallArgumentsMapping(_0 as [unknown, unknown, unknown]), input])
export const GenericCall = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(GenericCallArguments(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.GenericCallMapping(_0 as [unknown, unknown]), input])
export const KeywordString = (input: string): [unknown, string] | [] => If(Token.Const('string', input), ([_0, input]) => [S.KeywordStringMapping(_0 as 'string'), input])
export const KeywordNumber = (input: string): [unknown, string] | [] => If(Token.Const('number', input), ([_0, input]) => [S.KeywordNumberMapping(_0 as 'number'), input])
export const KeywordBoolean = (input: string): [unknown, string] | [] => If(Token.Const('boolean', input), ([_0, input]) => [S.KeywordBooleanMapping(_0 as 'boolean'), input])
export const KeywordUndefined = (input: string): [unknown, string] | [] => If(Token.Const('undefined', input), ([_0, input]) => [S.KeywordUndefinedMapping(_0 as 'undefined'), input])
export const KeywordNull = (input: string): [unknown, string] | [] => If(Token.Const('null', input), ([_0, input]) => [S.KeywordNullMapping(_0 as 'null'), input])
export const KeywordInteger = (input: string): [unknown, string] | [] => If(Token.Const('integer', input), ([_0, input]) => [S.KeywordIntegerMapping(_0 as 'integer'), input])
export const KeywordBigInt = (input: string): [unknown, string] | [] => If(Token.Const('bigint', input), ([_0, input]) => [S.KeywordBigIntMapping(_0 as 'bigint'), input])
export const KeywordUnknown = (input: string): [unknown, string] | [] => If(Token.Const('unknown', input), ([_0, input]) => [S.KeywordUnknownMapping(_0 as 'unknown'), input])
export const KeywordAny = (input: string): [unknown, string] | [] => If(Token.Const('any', input), ([_0, input]) => [S.KeywordAnyMapping(_0 as 'any'), input])
export const KeywordObject = (input: string): [unknown, string] | [] => If(Token.Const('object', input), ([_0, input]) => [S.KeywordObjectMapping(_0 as 'object'), input])
export const KeywordNever = (input: string): [unknown, string] | [] => If(Token.Const('never', input), ([_0, input]) => [S.KeywordNeverMapping(_0 as 'never'), input])
export const KeywordSymbol = (input: string): [unknown, string] | [] => If(Token.Const('symbol', input), ([_0, input]) => [S.KeywordSymbolMapping(_0 as 'symbol'), input])
export const KeywordVoid = (input: string): [unknown, string] | [] => If(Token.Const('void', input), ([_0, input]) => [S.KeywordVoidMapping(_0 as 'void'), input])
export const KeywordThis = (input: string): [unknown, string] | [] => If(Token.Const('this', input), ([_0, input]) => [S.KeywordThisMapping(_0 as 'this'), input])
export const Keyword = (input: string): [unknown, string] | [] => If(If(KeywordString(input), ([_0, input]) => [_0, input], () => If(KeywordNumber(input), ([_0, input]) => [_0, input], () => If(KeywordBoolean(input), ([_0, input]) => [_0, input], () => If(KeywordUndefined(input), ([_0, input]) => [_0, input], () => If(KeywordNull(input), ([_0, input]) => [_0, input], () => If(KeywordInteger(input), ([_0, input]) => [_0, input], () => If(KeywordBigInt(input), ([_0, input]) => [_0, input], () => If(KeywordUnknown(input), ([_0, input]) => [_0, input], () => If(KeywordAny(input), ([_0, input]) => [_0, input], () => If(KeywordObject(input), ([_0, input]) => [_0, input], () => If(KeywordNever(input), ([_0, input]) => [_0, input], () => If(KeywordSymbol(input), ([_0, input]) => [_0, input], () => If(KeywordVoid(input), ([_0, input]) => [_0, input], () => If(KeywordThis(input), ([_0, input]) => [_0, input], () => [])))))))))))))), ([_0, input]) => [S.KeywordMapping(_0 as unknown), input])
export const TemplateInterpolate = (input: string): [unknown, string] | [] => If(If(Token.Const('${', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TemplateInterpolateMapping(_0 as [unknown, unknown, unknown]), input])
export const TemplateSpan = (input: string): [unknown, string] | [] => If(Token.Until(['${', '`'], input), ([_0, input]) => [S.TemplateSpanMapping(_0 as string), input])
export const TemplateBody = (input: string): [unknown, string] | [] => If(If(If(TemplateSpan(input), ([_0, input]) => If(TemplateInterpolate(input), ([_1, input]) => If(TemplateBody(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(TemplateSpan(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(TemplateSpan(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.TemplateBodyMapping(_0 as [unknown, unknown, unknown] | [unknown]), input])
export const TemplateLiteralTypes = (input: string): [unknown, string] | [] => If(If(Token.Const('`', input), ([_0, input]) => If(TemplateBody(input), ([_1, input]) => If(Token.Const('`', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TemplateLiteralTypesMapping(_0 as [unknown, unknown, unknown]), input])
export const TemplateLiteral = (input: string): [unknown, string] | [] => If(TemplateLiteralTypes(input), ([_0, input]) => [S.TemplateLiteralMapping(_0 as unknown), input])
export const LiteralBigInt = (input: string): [unknown, string] | [] => If(Token.BigInt(input), ([_0, input]) => [S.LiteralBigIntMapping(_0 as string), input])
export const LiteralBoolean = (input: string): [unknown, string] | [] => If(If(Token.Const('true', input), ([_0, input]) => [_0, input], () => If(Token.Const('false', input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.LiteralBooleanMapping(_0 as 'true' | 'false'), input])
export const LiteralNumber = (input: string): [unknown, string] | [] => If(Token.Number(input), ([_0, input]) => [S.LiteralNumberMapping(_0 as string), input])
export const LiteralString = (input: string): [unknown, string] | [] => If(Token.String(['\'', '\"'], input), ([_0, input]) => [S.LiteralStringMapping(_0 as string), input])
export const Literal = (input: string): [unknown, string] | [] => If(If(LiteralBigInt(input), ([_0, input]) => [_0, input], () => If(LiteralBoolean(input), ([_0, input]) => [_0, input], () => If(LiteralNumber(input), ([_0, input]) => [_0, input], () => If(LiteralString(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.LiteralMapping(_0 as unknown), input])
export const KeyOf = (input: string): [unknown, string] | [] => If(If(If(Token.Const('keyof', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.KeyOfMapping(_0 as [unknown] | []), input])
export const IndexArray_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(If(Token.Const('[', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(Token.Const('[', input), ([_0, input]) => If(Token.Const(']', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => IndexArray_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const IndexArray = (input: string): [unknown, string] | [] => If(IndexArray_0(input), ([_0, input]) => [S.IndexArrayMapping(_0 as ([unknown, unknown, unknown] | [unknown, unknown])[]), input])
export const Extends = (input: string): [unknown, string] | [] => If(If(If(Token.Const('extends', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const('?', input), ([_2, input]) => If(Type(input), ([_3, input]) => If(Token.Const(':', input), ([_4, input]) => If(Type(input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExtendsMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown] | []), input])
export const Base = (input: string): [unknown, string] | [] => If(If(If(Token.Const('(', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const(')', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(Keyword(input), ([_0, input]) => [_0, input], () => If(Object(input), ([_0, input]) => [_0, input], () => If(Tuple(input), ([_0, input]) => [_0, input], () => If(TemplateLiteral(input), ([_0, input]) => [_0, input], () => If(Literal(input), ([_0, input]) => [_0, input], () => If(Constructor(input), ([_0, input]) => [_0, input], () => If(Function(input), ([_0, input]) => [_0, input], () => If(Mapped(input), ([_0, input]) => [_0, input], () => If(Options(input), ([_0, input]) => [_0, input], () => If(GenericCall(input), ([_0, input]) => [_0, input], () => If(Reference(input), ([_0, input]) => [_0, input], () => [])))))))))))), ([_0, input]) => [S.BaseMapping(_0 as [unknown, unknown, unknown] | unknown), input])
export const Factor = (input: string): [unknown, string] | [] => If(If(KeyOf(input), ([_0, input]) => If(Base(input), ([_1, input]) => If(IndexArray(input), ([_2, input]) => If(Extends(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.FactorMapping(_0 as [unknown, unknown, unknown, unknown]), input])
export const ExprTermTail = (input: string): [unknown, string] | [] => If(If(If(Token.Const('&', input), ([_0, input]) => If(Factor(input), ([_1, input]) => If(ExprTermTail(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExprTermTailMapping(_0 as [unknown, unknown, unknown] | []), input])
export const ExprTerm = (input: string): [unknown, string] | [] => If(If(Factor(input), ([_0, input]) => If(ExprTermTail(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprTermMapping(_0 as [unknown, unknown]), input])
export const ExprTail = (input: string): [unknown, string] | [] => If(If(If(Token.Const('|', input), ([_0, input]) => If(ExprTerm(input), ([_1, input]) => If(ExprTail(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExprTailMapping(_0 as [unknown, unknown, unknown] | []), input])
export const Expr = (input: string): [unknown, string] | [] => If(If(ExprTerm(input), ([_0, input]) => If(ExprTail(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprMapping(_0 as [unknown, unknown]), input])
export const ExprPipe = (input: string): [unknown, string] | [] => If(If(Token.Const('|', input), ([_0, input]) => If(Expr(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ExprPipeMapping(_0 as [unknown, unknown]), input])
export const GenericType = (input: string): [unknown, string] | [] => If(If(GenericParameters(input), ([_0, input]) => If(Token.Const('=', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.GenericTypeMapping(_0 as [unknown, unknown, unknown]), input])
export const InferType = (input: string): [unknown, string] | [] => If(If(If(Token.Const('infer', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(Token.Const('extends', input), ([_2, input]) => If(Expr(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [_0, input], () => If(If(Token.Const('infer', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.InferTypeMapping(_0 as [unknown, unknown, unknown, unknown] | [unknown, unknown]), input])
export const Type = (input: string): [unknown, string] | [] => If(If(InferType(input), ([_0, input]) => [_0, input], () => If(ExprPipe(input), ([_0, input]) => [_0, input], () => If(Expr(input), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.TypeMapping(_0 as unknown), input])
export const PropertyKeyNumber = (input: string): [unknown, string] | [] => If(Token.Number(input), ([_0, input]) => [S.PropertyKeyNumberMapping(_0 as string), input])
export const PropertyKeyIdent = (input: string): [unknown, string] | [] => If(Token.Ident(input), ([_0, input]) => [S.PropertyKeyIdentMapping(_0 as string), input])
export const PropertyKeyQuoted = (input: string): [unknown, string] | [] => If(Token.String(['\'', '\"'], input), ([_0, input]) => [S.PropertyKeyQuotedMapping(_0 as string), input])
export const PropertyKeyIndex = (input: string): [unknown, string] | [] => If(If(Token.Const('[', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(If(KeywordInteger(input), ([_0, input]) => [_0, input], () => If(KeywordNumber(input), ([_0, input]) => [_0, input], () => If(KeywordString(input), ([_0, input]) => [_0, input], () => If(KeywordSymbol(input), ([_0, input]) => [_0, input], () => [])))), ([_3, input]) => If(Token.Const(']', input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.PropertyKeyIndexMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const PropertyKey = (input: string): [unknown, string] | [] => If(If(PropertyKeyNumber(input), ([_0, input]) => [_0, input], () => If(PropertyKeyIdent(input), ([_0, input]) => [_0, input], () => If(PropertyKeyQuoted(input), ([_0, input]) => [_0, input], () => If(PropertyKeyIndex(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.PropertyKeyMapping(_0 as unknown), input])
export const Readonly = (input: string): [unknown, string] | [] => If(If(If(Token.Const('readonly', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ReadonlyMapping(_0 as [unknown] | []), input])
export const Optional = (input: string): [unknown, string] | [] => If(If(If(Token.Const('?', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.OptionalMapping(_0 as [unknown] | []), input])
export const Property = (input: string): [unknown, string] | [] => If(If(Readonly(input), ([_0, input]) => If(PropertyKey(input), ([_1, input]) => If(Optional(input), ([_2, input]) => If(Token.Const(':', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.PropertyMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const PropertyDelimiter = (input: string): [unknown, string] | [] => If(If(If(Token.Const(',', input), ([_0, input]) => If(Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const(';', input), ([_0, input]) => If(Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const(',', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(Token.Const(';', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(Token.Const('\n', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))))), ([_0, input]) => [S.PropertyDelimiterMapping(_0 as [unknown, unknown] | [unknown]), input])
export const PropertyList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(Property(input), ([_0, input]) => If(PropertyDelimiter(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => PropertyList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const PropertyList = (input: string): [unknown, string] | [] => If(If(PropertyList_0(input), ([_0, input]) => If(If(If(Property(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.PropertyListMapping(_0 as [unknown, unknown]), input])
export const Properties = (input: string): [unknown, string] | [] => If(If(Token.Const('{', input), ([_0, input]) => If(PropertyList(input), ([_1, input]) => If(Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.PropertiesMapping(_0 as [unknown, unknown, unknown]), input])
export const Object = (input: string): [unknown, string] | [] => If(Properties(input), ([_0, input]) => [S.ObjectMapping(_0 as unknown), input])
export const ElementNamed = (input: string): [unknown, string] | [] => If(If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Token.Const('readonly', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [_0, input], () => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Token.Const('readonly', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [_0, input], () => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [_0, input], () => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.ElementNamedMapping(_0 as [unknown, unknown, unknown, unknown, unknown] | [unknown, unknown, unknown, unknown] | [unknown, unknown, unknown]), input])
export const ElementReadonlyOptional = (input: string): [unknown, string] | [] => If(If(Token.Const('readonly', input), ([_0, input]) => If(Type(input), ([_1, input]) => If(Token.Const('?', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.ElementReadonlyOptionalMapping(_0 as [unknown, unknown, unknown]), input])
export const ElementReadonly = (input: string): [unknown, string] | [] => If(If(Token.Const('readonly', input), ([_0, input]) => If(Type(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementReadonlyMapping(_0 as [unknown, unknown]), input])
export const ElementOptional = (input: string): [unknown, string] | [] => If(If(Type(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementOptionalMapping(_0 as [unknown, unknown]), input])
export const ElementBase = (input: string): [unknown, string] | [] => If(If(ElementNamed(input), ([_0, input]) => [_0, input], () => If(ElementReadonlyOptional(input), ([_0, input]) => [_0, input], () => If(ElementReadonly(input), ([_0, input]) => [_0, input], () => If(ElementOptional(input), ([_0, input]) => [_0, input], () => If(Type(input), ([_0, input]) => [_0, input], () => []))))), ([_0, input]) => [S.ElementBaseMapping(_0 as unknown), input])
export const Element = (input: string): [unknown, string] | [] => If(If(If(Token.Const('...', input), ([_0, input]) => If(ElementBase(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(ElementBase(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ElementMapping(_0 as [unknown, unknown] | [unknown]), input])
export const ElementList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(Element(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => ElementList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const ElementList = (input: string): [unknown, string] | [] => If(If(ElementList_0(input), ([_0, input]) => If(If(If(Element(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ElementListMapping(_0 as [unknown, unknown]), input])
export const Tuple = (input: string): [unknown, string] | [] => If(If(Token.Const('[', input), ([_0, input]) => If(ElementList(input), ([_1, input]) => If(Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.TupleMapping(_0 as [unknown, unknown, unknown]), input])
export const ParameterReadonlyOptional = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Token.Const('readonly', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.ParameterReadonlyOptionalMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const ParameterReadonly = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Token.Const('readonly', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ParameterReadonlyMapping(_0 as [unknown, unknown, unknown, unknown]), input])
export const ParameterOptional = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => If(Token.Const(':', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.ParameterOptionalMapping(_0 as [unknown, unknown, unknown, unknown]), input])
export const ParameterType = (input: string): [unknown, string] | [] => If(If(Token.Ident(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Type(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.ParameterTypeMapping(_0 as [unknown, unknown, unknown]), input])
export const ParameterBase = (input: string): [unknown, string] | [] => If(If(ParameterReadonlyOptional(input), ([_0, input]) => [_0, input], () => If(ParameterReadonly(input), ([_0, input]) => [_0, input], () => If(ParameterOptional(input), ([_0, input]) => [_0, input], () => If(ParameterType(input), ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.ParameterBaseMapping(_0 as unknown), input])
export const Parameter = (input: string): [unknown, string] | [] => If(If(If(Token.Const('...', input), ([_0, input]) => If(ParameterBase(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(ParameterBase(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ParameterMapping(_0 as [unknown, unknown] | [unknown]), input])
export const ParameterList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(Parameter(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => ParameterList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const ParameterList = (input: string): [unknown, string] | [] => If(If(ParameterList_0(input), ([_0, input]) => If(If(If(Parameter(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ParameterListMapping(_0 as [unknown, unknown]), input])
export const Function = (input: string): [unknown, string] | [] => If(If(Token.Const('(', input), ([_0, input]) => If(ParameterList(input), ([_1, input]) => If(Token.Const(')', input), ([_2, input]) => If(Token.Const('=>', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.FunctionMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const Constructor = (input: string): [unknown, string] | [] => If(If(Token.Const('new', input), ([_0, input]) => If(Token.Const('(', input), ([_1, input]) => If(ParameterList(input), ([_2, input]) => If(Token.Const(')', input), ([_3, input]) => If(Token.Const('=>', input), ([_4, input]) => If(Type(input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.ConstructorMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown]), input])
export const MappedReadonly = (input: string): [unknown, string] | [] => If(If(If(Token.Const('+', input), ([_0, input]) => If(Token.Const('readonly', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('-', input), ([_0, input]) => If(Token.Const('readonly', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('readonly', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.MappedReadonlyMapping(_0 as [unknown, unknown] | [unknown] | []), input])
export const MappedOptional = (input: string): [unknown, string] | [] => If(If(If(Token.Const('+', input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('-', input), ([_0, input]) => If(Token.Const('?', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const('?', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])))), ([_0, input]) => [S.MappedOptionalMapping(_0 as [unknown, unknown] | [unknown] | []), input])
export const MappedAs = (input: string): [unknown, string] | [] => If(If(If(Token.Const('as', input), ([_0, input]) => If(Type(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.MappedAsMapping(_0 as [unknown, unknown] | []), input])
export const Mapped = (input: string): [unknown, string] | [] => If(If(Token.Const('{', input), ([_0, input]) => If(MappedReadonly(input), ([_1, input]) => If(Token.Const('[', input), ([_2, input]) => If(Token.Ident(input), ([_3, input]) => If(Token.Const('in', input), ([_4, input]) => If(Type(input), ([_5, input]) => If(MappedAs(input), ([_6, input]) => If(Token.Const(']', input), ([_7, input]) => If(MappedOptional(input), ([_8, input]) => If(Token.Const(':', input), ([_9, input]) => If(Type(input), ([_10, input]) => If(Token.Const('}', input), ([_11, input]) => [[_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11], input])))))))))))), ([_0, input]) => [S.MappedMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown]), input])
export const Reference = (input: string): [unknown, string] | [] => If(Token.Ident(input), ([_0, input]) => [S.ReferenceMapping(_0 as string), input])
export const Options = (input: string): [unknown, string] | [] => If(If(Token.Const('Options', input), ([_0, input]) => If(Token.Const('<', input), ([_1, input]) => If(Type(input), ([_2, input]) => If(Token.Const(',', input), ([_3, input]) => If(JsonObject(input), ([_4, input]) => If(Token.Const('>', input), ([_5, input]) => [[_0, _1, _2, _3, _4, _5], input])))))), ([_0, input]) => [S.OptionsMapping(_0 as [unknown, unknown, unknown, unknown, unknown, unknown]), input])
export const JsonNumber = (input: string): [unknown, string] | [] => If(Token.Number(input), ([_0, input]) => [S.JsonNumberMapping(_0 as string), input])
export const JsonBoolean = (input: string): [unknown, string] | [] => If(If(Token.Const('true', input), ([_0, input]) => [_0, input], () => If(Token.Const('false', input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.JsonBooleanMapping(_0 as 'true' | 'false'), input])
export const JsonString = (input: string): [unknown, string] | [] => If(Token.String(['\"', '\''], input), ([_0, input]) => [S.JsonStringMapping(_0 as string), input])
export const JsonNull = (input: string): [unknown, string] | [] => If(Token.Const('null', input), ([_0, input]) => [S.JsonNullMapping(_0 as 'null'), input])
export const JsonProperty = (input: string): [unknown, string] | [] => If(If(PropertyKey(input), ([_0, input]) => If(Token.Const(':', input), ([_1, input]) => If(Json(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.JsonPropertyMapping(_0 as [unknown, unknown, unknown]), input])
export const JsonPropertyList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(JsonProperty(input), ([_0, input]) => If(PropertyDelimiter(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => JsonPropertyList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const JsonPropertyList = (input: string): [unknown, string] | [] => If(If(JsonPropertyList_0(input), ([_0, input]) => If(If(If(JsonProperty(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.JsonPropertyListMapping(_0 as [unknown, unknown]), input])
export const JsonObject = (input: string): [unknown, string] | [] => If(If(Token.Const('{', input), ([_0, input]) => If(JsonPropertyList(input), ([_1, input]) => If(Token.Const('}', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.JsonObjectMapping(_0 as [unknown, unknown, unknown]), input])
export const JsonElementList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(Json(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => JsonElementList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const JsonElementList = (input: string): [unknown, string] | [] => If(If(JsonElementList_0(input), ([_0, input]) => If(If(If(Json(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.JsonElementListMapping(_0 as [unknown, unknown]), input])
export const JsonArray = (input: string): [unknown, string] | [] => If(If(Token.Const('[', input), ([_0, input]) => If(JsonElementList(input), ([_1, input]) => If(Token.Const(']', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.JsonArrayMapping(_0 as [unknown, unknown, unknown]), input])
export const Json = (input: string): [unknown, string] | [] => If(If(JsonNumber(input), ([_0, input]) => [_0, input], () => If(JsonBoolean(input), ([_0, input]) => [_0, input], () => If(JsonString(input), ([_0, input]) => [_0, input], () => If(JsonNull(input), ([_0, input]) => [_0, input], () => If(JsonObject(input), ([_0, input]) => [_0, input], () => If(JsonArray(input), ([_0, input]) => [_0, input], () => [])))))), ([_0, input]) => [S.JsonMapping(_0 as unknown), input])
export const PatternBigInt = (input: string): [unknown, string] | [] => If(Token.Const('-?(?:0|[1-9][0-9]*)n', input), ([_0, input]) => [S.PatternBigIntMapping(_0 as '-?(?:0|[1-9][0-9]*)n'), input])
export const PatternString = (input: string): [unknown, string] | [] => If(Token.Const('.*', input), ([_0, input]) => [S.PatternStringMapping(_0 as '.*'), input])
export const PatternNumber = (input: string): [unknown, string] | [] => If(Token.Const('-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', input), ([_0, input]) => [S.PatternNumberMapping(_0 as '-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?'), input])
export const PatternInteger = (input: string): [unknown, string] | [] => If(Token.Const('-?(?:0|[1-9][0-9]*)', input), ([_0, input]) => [S.PatternIntegerMapping(_0 as '-?(?:0|[1-9][0-9]*)'), input])
export const PatternNever = (input: string): [unknown, string] | [] => If(Token.Const('(?!)', input), ([_0, input]) => [S.PatternNeverMapping(_0 as '(?!)'), input])
export const PatternText = (input: string): [unknown, string] | [] => If(Token.Until_1(['-?(?:0|[1-9][0-9]*)n', '.*', '-?(?:0|[1-9][0-9]*)(?:.[0-9]+)?', '-?(?:0|[1-9][0-9]*)', '(?!)', '(', ')', '$', '|'], input), ([_0, input]) => [S.PatternTextMapping(_0 as string), input])
export const PatternBase = (input: string): [unknown, string] | [] => If(If(PatternBigInt(input), ([_0, input]) => [_0, input], () => If(PatternString(input), ([_0, input]) => [_0, input], () => If(PatternNumber(input), ([_0, input]) => [_0, input], () => If(PatternInteger(input), ([_0, input]) => [_0, input], () => If(PatternNever(input), ([_0, input]) => [_0, input], () => If(PatternGroup(input), ([_0, input]) => [_0, input], () => If(PatternText(input), ([_0, input]) => [_0, input], () => []))))))), ([_0, input]) => [S.PatternBaseMapping(_0 as unknown), input])
export const PatternGroup = (input: string): [unknown, string] | [] => If(If(Token.Const('(', input), ([_0, input]) => If(PatternBody(input), ([_1, input]) => If(Token.Const(')', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.PatternGroupMapping(_0 as [unknown, unknown, unknown]), input])
export const PatternUnion = (input: string): [unknown, string] | [] => If(If(If(PatternTerm(input), ([_0, input]) => If(Token.Const('|', input), ([_1, input]) => If(PatternUnion(input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [_0, input], () => If(If(PatternTerm(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.PatternUnionMapping(_0 as [unknown, unknown, unknown] | [unknown] | []), input])
export const PatternTerm = (input: string): [unknown, string] | [] => If(If(PatternBase(input), ([_0, input]) => If(PatternBody(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.PatternTermMapping(_0 as [unknown, unknown]), input])
export const PatternBody = (input: string): [unknown, string] | [] => If(If(PatternUnion(input), ([_0, input]) => [_0, input], () => If(PatternTerm(input), ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.PatternBodyMapping(_0 as unknown), input])
export const Pattern = (input: string): [unknown, string] | [] => If(If(Token.Const('^', input), ([_0, input]) => If(PatternBody(input), ([_1, input]) => If(Token.Const('$', input), ([_2, input]) => [[_0, _1, _2], input]))), ([_0, input]) => [S.PatternMapping(_0 as [unknown, unknown, unknown]), input])
export const InterfaceDeclarationHeritageList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(Type(input), ([_0, input]) => If(Token.Const(',', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => InterfaceDeclarationHeritageList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const InterfaceDeclarationHeritageList = (input: string): [unknown, string] | [] => If(If(InterfaceDeclarationHeritageList_0(input), ([_0, input]) => If(If(If(Type(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.InterfaceDeclarationHeritageListMapping(_0 as [unknown, unknown]), input])
export const InterfaceDeclarationHeritage = (input: string): [unknown, string] | [] => If(If(If(Token.Const('extends', input), ([_0, input]) => If(InterfaceDeclarationHeritageList(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.InterfaceDeclarationHeritageMapping(_0 as [unknown, unknown] | []), input])
export const InterfaceDeclarationGeneric = (input: string): [unknown, string] | [] => If(If(Token.Const('interface', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(GenericParameters(input), ([_2, input]) => If(InterfaceDeclarationHeritage(input), ([_3, input]) => If(Properties(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.InterfaceDeclarationGenericMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const InterfaceDeclaration = (input: string): [unknown, string] | [] => If(If(Token.Const('interface', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(InterfaceDeclarationHeritage(input), ([_2, input]) => If(Properties(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.InterfaceDeclarationMapping(_0 as [unknown, unknown, unknown, unknown]), input])
export const TypeAliasDeclarationGeneric = (input: string): [unknown, string] | [] => If(If(Token.Const('type', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(GenericParameters(input), ([_2, input]) => If(Token.Const('=', input), ([_3, input]) => If(Type(input), ([_4, input]) => [[_0, _1, _2, _3, _4], input]))))), ([_0, input]) => [S.TypeAliasDeclarationGenericMapping(_0 as [unknown, unknown, unknown, unknown, unknown]), input])
export const TypeAliasDeclaration = (input: string): [unknown, string] | [] => If(If(Token.Const('type', input), ([_0, input]) => If(Token.Ident(input), ([_1, input]) => If(Token.Const('=', input), ([_2, input]) => If(Type(input), ([_3, input]) => [[_0, _1, _2, _3], input])))), ([_0, input]) => [S.TypeAliasDeclarationMapping(_0 as [unknown, unknown, unknown, unknown]), input])
export const ExportKeyword = (input: string): [unknown, string] | [] => If(If(If(Token.Const('export', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_0, input]) => [S.ExportKeywordMapping(_0 as [unknown] | []), input])
export const ModuleDeclarationDelimiter = (input: string): [unknown, string] | [] => If(If(If(Token.Const(';', input), ([_0, input]) => If(Token.Const('\n', input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [_0, input], () => If(If(Token.Const(';', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If(If(Token.Const('\n', input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.ModuleDeclarationDelimiterMapping(_0 as [unknown, unknown] | [unknown]), input])
export const ModuleDeclarationList_0 = (input: string, result: unknown[] = []): [unknown[], string] => If(If(ModuleDeclaration(input), ([_0, input]) => If(ModuleDeclarationDelimiter(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => ModuleDeclarationList_0(input, [...result, _0]), () => [result, input]) as [unknown[], string]
export const ModuleDeclarationList = (input: string): [unknown, string] | [] => If(If(ModuleDeclarationList_0(input), ([_0, input]) => If(If(If(ModuleDeclaration(input), ([_0, input]) => [[_0], input]), ([_0, input]) => [_0, input], () => If([[], input], ([_0, input]) => [_0, input], () => [])), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ModuleDeclarationListMapping(_0 as [unknown, unknown]), input])
export const ModuleDeclaration = (input: string): [unknown, string] | [] => If(If(ExportKeyword(input), ([_0, input]) => If(If(InterfaceDeclarationGeneric(input), ([_0, input]) => [_0, input], () => If(InterfaceDeclaration(input), ([_0, input]) => [_0, input], () => If(TypeAliasDeclarationGeneric(input), ([_0, input]) => [_0, input], () => If(TypeAliasDeclaration(input), ([_0, input]) => [_0, input], () => [])))), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ModuleDeclarationMapping(_0 as [unknown, unknown]), input])
export const Module = (input: string): [unknown, string] | [] => If(If(ModuleDeclaration(input), ([_0, input]) => If(ModuleDeclarationList(input), ([_1, input]) => [[_0, _1], input])), ([_0, input]) => [S.ModuleMapping(_0 as [unknown, unknown]), input])
export const Script = (input: string): [unknown, string] | [] => If(If(Module(input), ([_0, input]) => [_0, input], () => If(GenericType(input), ([_0, input]) => [_0, input], () => If(Type(input), ([_0, input]) => [_0, input], () => []))), ([_0, input]) => [S.ScriptMapping(_0 as unknown), input])